<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Circuit Drafter - Effortless circuit schematics</title>
    <!-- Google Material Icons -->
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0&icon_names=folder_open"
    />
    <!-- Google Material Icons -->

    <!-- Link to Google Font (Outfit) -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Outfit:wght@700&display=swap"
      rel="stylesheet"
    />

    <style>
      body {
        font-family: "Georgia", "Times New Roman", Times, serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 0;
        padding: 20px;
        background-color: #f8f9fa;
        color: #333;
      }
      h1 {
        font-family: "Outfit", sans-serif;
        font-weight: 700;
        color: #212529;
      }
      #toolbar {
        margin-bottom: 20px;
        background: #ffffff;
        padding: 10px;
        border-radius: 12px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
        border: 1px solid #e9ecef;
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      .tool-group {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .tool-btn,
      .action-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 44px;
        height: 44px;
        border: 1px solid #ced4da;
        background-color: #ffffff;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease-out;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        font-size: 24px;
        color: #495057;
      }
      .tool-btn:hover,
      .action-btn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        border-color: #adb5bd;
      }
      .tool-btn:active,
      .action-btn:active:not(:disabled) {
        transform: translateY(1px);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        background-color: #f8f9fa;
        transition-duration: 0.1s;
      }
      .tool-btn.selected,
      .action-btn.selected {
        background-color: #007bff;
        border-color: #007bff;
        color: white;
        box-shadow: 0 2px 5px rgba(0, 123, 255, 0.3);
      }
      .tool-btn svg {
        width: 28px;
        height: 28px;
        stroke-width: 1.5;
        stroke: #495057;
        transition: all 0.2s ease-out;
      }
      /* Universal rule for selected button icons */
      .tool-btn.selected svg,
      .tool-btn.selected .material-icons,
      .action-btn.selected svg,
      .action-btn.selected .material-icons {
        stroke: white;
        color: white;
      }
      /* Rule for filling shapes within selected icons */
      .tool-btn.selected svg path[fill]:not([fill="none"]) {
        fill: white;
      }
      /* Rule for filling shapes within normal icons */
      .tool-btn svg path[fill]:not([fill="none"]) {
        fill: #495057;
      }
      /* Specific override for select icon arrow */
      .tool-btn #select-icon-arrow {
        fill: #495057;
      }
      .tool-btn.selected #select-icon-arrow {
        fill: white;
      }
      .divider {
        width: 1px;
        height: 35px;
        background-color: #e9ecef;
        margin: 0 8px;
      }
      .action-btn:disabled {
        color: #adb5bd;
        background-color: #e9ecef;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
        border-color: #ced4da;
      }
      /* --- START: Style for the new green file button --- */
      #fileOpsBtn {
        background-color: #28a745;
        border-color: #28a745;
        color: white;
      }
      #fileOpsBtn:hover:not(:disabled) {
        background-color: #218838;
        border-color: #1e7e34;
      }
      /* --- END: Style for the new green file button --- */
      #circuitCanvas {
        border: 1px solid #dee2e6;
        border-radius: 8px;
        background-color: #fff;
      }
      .tool-dropdown {
        position: relative;
        display: inline-block;
      }
      .dropdown-trigger {
        cursor: default;
      }
      .dropdown-content {
        display: flex;
        flex-direction: column;
        gap: 6px;
        position: absolute;
        top: calc(100% + 5px);
        left: 50%;
        transform: translateX(-50%) translateY(-10px);
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        transition: opacity 0.2s ease-out, transform 0.2s ease-out,
          visibility 0.2s;
        background-color: #ffffff;
        padding: 8px;
        border-radius: 8px;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.12);
        border: 1px solid #e9ecef;
        z-index: 10;
      }
      .tool-dropdown:hover .dropdown-content {
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
        transform: translateX(-50%) translateY(0);
      }
      #helpBtn {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 50px;
        height: 50px;
        background-color: #ffffff;
        border-radius: 50%;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        text-decoration: none;
        transition: all 0.2s ease-out;
      }
      #helpBtn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        background-color: #f8f9fa;
      }
      #helpBtn .material-icons {
        font-size: 28px;
        color: #007bff;
      }
      .title-container {
        display: flex;
        align-items: center;
        gap: 15px;
        margin-bottom: 20px;
      }
      .logo {
        height: 75px;
      }
      h1 {
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
        font-weight: 600;
        letter-spacing: 0.5px;
        color: #343a40;
      }
      #tagline {
        margin: 2px 0 0 0;
        font-size: 1.1rem;
        color: #6c757d;
        font-weight: 400;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
      }

      /* --- START: Modal Styles --- */
      .modal-overlay {
        display: none; /* Hidden by default */
        position: fixed;
        z-index: 1001;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.5);
        align-items: center;
        justify-content: center;
      }
      .modal-content {
        background-color: #fefefe;
        margin: auto;
        padding: 20px 30px;
        border: 1px solid #888;
        width: 80%;
        max-width: 600px;
        border-radius: 12px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        position: relative;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
      }
      .modal-close {
        color: #aaa;
        position: absolute;
        top: 10px;
        right: 20px;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
      }
      .modal-close:hover,
      .modal-close:focus {
        color: black;
        text-decoration: none;
      }
      .modal-content h3 {
        margin-top: 0;
        color: #343a40;
      }
      .modal-table-container {
        max-height: 40vh;
        overflow-y: auto;
        margin: 20px 0;
        border: 1px solid #dee2e6;
        border-radius: 8px;
      }
      #bulk-input-table {
        width: 100%;
        border-collapse: collapse;
      }
      #bulk-input-table th,
      #bulk-input-table td {
        border-bottom: 1px solid #dee2e6;
        padding: 12px;
        text-align: left;
      }
      #bulk-input-table th {
        background-color: #f8f9fa;
        position: sticky;
        top: 0;
      }
      #bulk-input-table td input {
        width: 95%;
        padding: 8px;
        border: 1px solid #ced4da;
        border-radius: 4px;
        font-size: 14px;
      }
      #bulk-input-table .delete-row-btn {
        background: none;
        border: none;
        color: #dc3545;
        cursor: pointer;
        font-size: 24px;
        line-height: 1;
        padding: 0 5px;
      }
      .modal-actions {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        margin-top: 20px;
      }
      .modal-button {
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-weight: 500;
        transition: background-color 0.2s;
        font-size: 1rem;
      }
      .modal-button.primary {
        background-color: #007bff;
        color: white;
      }
      .modal-button.primary:hover {
        background-color: #0056b3;
      }
      .modal-button.secondary {
        background-color: #6c757d;
        color: white;
      }
      .modal-button.secondary:hover {
        background-color: #5a6268;
      }
      #add-row-btn {
        background-color: #28a745;
        color: white;
      }
      #add-row-btn:hover {
        background-color: #218838;
      }
      /* Style for textareas */
      #bulk-text-input,
      #text-input-area {
        width: 98%;
        min-height: 120px;
        margin-top: 10px;
        padding: 10px;
        border: 1px solid #ced4da;
        border-radius: 8px;
        font-size: 1rem;
        font-family: inherit;
        resize: vertical;
      }
      /* --- START: Style for new Text Modal Options --- */
      .text-modal-options {
        margin-top: 15px;
        display: flex;
        align-items: center;
      }
      .text-modal-options label {
        display: flex;
        align-items: center;
        cursor: pointer;
        font-size: 0.95rem;
        color: #495057;
      }
      .text-modal-options input[type="checkbox"] {
        margin-right: 8px;
        /* Simple styling for the checkbox */
        width: 16px;
        height: 16px;
      }
      /* --- END: Style for new Text Modal Options --- */
      /* --- END: Modal Styles --- */
    </style>
  </head>
  <body>
    <div class="title-container">
      <img
        src="https://github.com/user-attachments/assets/29b49b83-8617-48fc-aabf-a31d292b27f1"
        alt="Circuit Drafter Logo"
        class="logo"
      />
      <div>
        <h1>Circuit Drafter (V0.40a)</h1>
        <p id="tagline">Effortless circuit schematics.</p>
      </div>
    </div>

    <a
      href="https://github.com/inverter3p/circuitdrafter/blob/main/README.md"
      target="_blank"
      rel="noopener noreferrer"
      id="helpBtn"
      title="Help / View Documentation"
    >
      <i class="material-icons">help_outline</i>
    </a>

    <div id="toolbar">
      <div class="tool-group">
        <button class="tool-btn" id="tool-select" title="Select/Move (S)">
          <svg viewBox="0 0 24 24">
            <path
              id="select-icon-box"
              d="M9 14 v7 h12 v-12 h-7"
              stroke-width="2"
              stroke-dasharray="3"
              fill="none"
              stroke-linecap="round"
            />
            <path id="select-icon-arrow" d="M4 3 L15 12 L11 14 L4 3Z" />
          </svg>
        </button>
        <button
          class="tool-btn"
          id="tool-wire"
          title="Wire (W, Shift for straight line, Ctrl+Click for dot)"
        >
          <svg viewBox="0 0 24 24">
            <path
              d="M4 12 L20 12"
              fill="none"
              stroke-linejoin="round"
              stroke-linecap="round"
            ></path>
            <circle cx="4" cy="12" r="2" stroke="red" fill="red" />
            <circle cx="20" cy="12" r="2" stroke="red" fill="red" />
          </svg>
        </button>
        <button class="tool-btn" id="tool-text" title="Text (T)">
          <i class="material-icons">text_fields</i>
        </button>
      </div>
      <div class="divider"></div>
      <div class="tool-group">
        <!-- START: RLC Dropdown -->
        <div class="tool-dropdown">
          <button class="tool-btn dropdown-trigger" title="Passive Components">
            <svg viewBox="-2 -10 34 20">
              <path
                d="M0,0 H4 L6,-6 L10,6 L14,-6 L18,6 L22,-6 L26,6 L28,0 H32"
                fill="none"
                stroke-linejoin="round"
                stroke-linecap="round"
              ></path>
            </svg>
          </button>
          <div class="dropdown-content">
            <button class="tool-btn" id="tool-resistor" title="Resistor">
              <svg viewBox="-2 -10 34 20">
                <path
                  d="M0,0 H4 L6,-6 L10,6 L14,-6 L18,6 L22,-6 L26,6 L28,0 H32"
                  fill="none"
                  stroke-linejoin="round"
                  stroke-linecap="round"
                ></path>
              </svg>
            </button>
            <button class="tool-btn" id="tool-capacitor" title="Capacitor">
              <svg viewBox="-5 -10 30 20">
                <path
                  d="M0,0 H10 M10,-8 V8 M15,-8 V8 M15,0 H25"
                  fill="none"
                  stroke-linecap="round"
                ></path>
              </svg>
            </button>
            <button class="tool-btn" id="tool-inductor" title="Inductor">
              <svg viewBox="-2 -10 34 20">
                <path
                  d="M0,0 H6 C9,-13 12,-13 15,1 C18,-13 21,-13 24,0 H32"
                  fill="none"
                  stroke-linecap="round"
                ></path>
              </svg>
            </button>
          </div>
        </div>
        <!-- END: RLC Dropdown -->
        <div class="tool-dropdown">
          <button class="tool-btn dropdown-trigger" title="Diodes">
            <svg viewBox="-2 -10 24 20">
              <path
                d="M-4,0 H12 M16,0 H22"
                fill="none"
                stroke-linejoin="round"
                stroke-linecap="round"
              />
              <path fill="#495057" d="M5,-6 V6 L16,0 Z" />
              <path
                d="M16,-6 V6"
                fill="none"
                stroke-linejoin="round"
                stroke-linecap="round"
              />
            </svg>
          </button>
          <div class="dropdown-content">
            <button class="tool-btn" id="tool-diode" title="Diode">
              <svg viewBox="-2 -10 24 20">
                <path
                  d="M-4,0 H12 M16,0 H22"
                  fill="none"
                  stroke-linejoin="round"
                  stroke-linecap="round"
                />
                <path fill="#495057" d="M5,-6 V6 L16,0 Z" />
                <path
                  d="M16,-6 V6"
                  fill="none"
                  stroke-linejoin="round"
                  stroke-linecap="round"
                />
              </svg>
            </button>
            <button class="tool-btn" id="tool-zener" title="Zener Diode">
              <svg viewBox="-2 -12 24 24">
                <path
                  d="M-4,0 H12 M16,0 H22"
                  fill="none"
                  stroke-linejoin="round"
                  stroke-linecap="round"
                />
                <path fill="#495057" d="M5,-6 V6 L16,0 Z" />
                <path
                  d="M16,-6 V6"
                  fill="none"
                  stroke-linejoin="round"
                  stroke-linecap="round"
                />
                <path d="M16,-6 L13,-8 M16,6 L19,8" stroke-linecap="round" />
              </svg>
            </button>
            <button class="tool-btn" id="tool-led" title="LED">
              <svg viewBox="-2 -16 26 26">
                <path d="M-4,0 H12 M16,0 H22" fill="none" />
                <path d="M5,-6 V6 L16,0 Z" fill="#495057" />
                <path d="M16,-6 V6" fill="none" />
                <path
                  d="M10,-10 L15,-15 M13,-15 H15 V-13"
                  fill="none"
                  stroke-linecap="round"
                />
                <path
                  d="M14,-8 L19,-13 M17,-13 H19 V-11"
                  fill="none"
                  stroke-linecap="round"
                />
              </svg>
            </button>
            <button
              class="tool-btn"
              id="tool-fwd"
              title="FWD"
              style="font-size: 14px; font-weight: bold"
            >
              FWD
            </button>
          </div>
        </div>
        <!-- START: Transistors Dropdown -->
        <div class="tool-dropdown">
          <button class="tool-btn dropdown-trigger" title="Transistors">
            <svg viewBox="-20 -20 40 40">
              <path
                d="M -20 0 h 10 M -10 -10 v 20 M 5 -18 v 6 M 5 -12 L -10 -5 M 5 18 v -6 M 5 12 L -10 5"
                fill="none"
                stroke-linecap="round"
                stroke-linejoin="round"
              ></path>
              <path fill="#495057" d="M5 12 L0 5 L -3 12 Z" />
            </svg>
          </button>
          <div class="dropdown-content">
            <button
              class="tool-btn"
              id="tool-npn"
              title="NPN"
              style="font-size: 14px; font-weight: bold"
            >
              <svg viewBox="-20 -20 40 40">
              <path
                d="M -20 0 h 10 M -10 -10 v 20 M 5 -18 v 6 M 5 -12 L -10 -5 M 5 18 v -6 M 5 12 L -10 5"
                fill="none"
                stroke-linecap="round"
                stroke-linejoin="round"
              ></path>
              <path fill="#495057" d="M5 12 L0 5 L -3 12 Z" />
            </svg>
            </button>
            <button
              class="tool-btn"
              id="tool-pnp"
              title="PNP"
              style="font-size: 14px; font-weight: bold"
            >
              <svg viewBox="-20 -20 40 40">
              <path
                d="M -20 0 h 10 M -10 -10 v 20 M 5 -18 v 6 M 5 -12 L -10 -5 M 5 18 v -6 M 5 12 L -10 5"
                fill="none"
                stroke-linecap="round"
                stroke-linejoin="round"
              ></path>
              <path fill="#495057" d="M-10 -5 L0 -5 L -3 -12 z" />
            </svg>
            </button>
            <button
              class="tool-btn"
              id="tool-nfet"
              title="N-CH"
              style="font-size: 12px; font-weight: bold"
            >
              N-CH
            </button>
            <button
              class="tool-btn"
              id="tool-pfet"
              title="N-CH"
              style="font-size: 12px; font-weight: bold"
            >
              P-CH
            </button>
            <button
              class="tool-btn"
              id="tool-igbt"
              title="IGBT"
              style="font-size: 14px; font-weight: bold"
            >
              IGBT
            </button>
          </div>
        </div>
        <!-- END: Switches & Transistors Dropdown -->
      </div>
      <div class="divider"></div>
      <div class="tool-group">
        <div class="tool-dropdown">
          <button class="tool-btn dropdown-trigger" title="Sources">
            <svg viewBox="-12 -12 24 24">
              <circle cx="0" cy="0" r="10" fill="none"></circle>
              <path d="M-3,-3 H4 M0,-7 V1, M-3,3 H4" fill="none"></path>
            </svg>
          </button>
          <div class="dropdown-content">
            <button
              class="tool-btn"
              id="tool-voltage"
              title="Voltage Source (DC)"
            >
              <svg viewBox="-12 -12 24 24">
                <circle cx="0" cy="0" r="10" fill="none"></circle>
                <path d="M-3,-3 H4 M0,-7 V1, M-3,3 H4" fill="none"></path>
              </svg>
            </button>
            <button
              class="tool-btn"
              id="tool-acvoltage"
              title="Voltage Source (AC)"
            >
              <svg viewBox="-12 -12 24 24">
                <circle cx="0" cy="0" r="10" fill="none"></circle>
                <path
                  d="M-8,0 Q-4,-10 0,0 T8,0"
                  fill="none"
                  stroke-linecap="round"
                ></path>
              </svg>
            </button>
            <button
              class="tool-btn"
              id="tool-currentsource"
              title="Current Source"
            >
              <svg viewBox="-12 -12 24 24">
                <circle cx="0" cy="0" r="10" fill="none"></circle>
                <path
                  d="M0,7 L0,-7 M-4,-2 L0,-7 L4,-2"
                  fill="none"
                  stroke-linecap="round"
                ></path>
              </svg>
            </button>
            <button
              class="tool-btn"
              id="tool-dependent_voltage"
              title="Dependent Voltage Source"
            >
              <svg viewBox="-12 -12 24 24">
                <path d="M0 -10 L10 0 L0 10 L-10 0 Z" fill="none"></path>
                <!-- Plus sign -->
                <path d="M-2.5 -5 L2.5 -5 M0 -7.5 L0 -2.5" fill="none"></path>
                <!-- Minus sign -->
                <path d="M-2.5 5 L2.5 5" fill="none"></path>
              </svg>
            </button>
            <button
              class="tool-btn"
              id="tool-dependent_current"
              title="Dependent Current Source"
            >
              <svg viewBox="-12 -12 24 24">
                <path d="M0 -10 L10 0 L0 10 L-10 0 Z" fill="none"></path>
                <!-- Arrow -->
                <path
                  d="M0 6 L0 -6 M-3 -2 L0 -6 L3 -2"
                  fill="none"
                  stroke-linecap="round"
                ></path>
              </svg>
            </button>
            <button class="tool-btn" id="tool-battery" title="Battery">
              <svg viewBox="-10 -10 20 20">
                <path
                  d="M-8,-8 H8 M-4,-3 H4 M-8,3 H8 M-4,8 H4"
                  stroke-width="1.5"
                  fill="none"
                ></path>
              </svg>
            </button>
            <button class="tool-btn" id="tool-gnd" title="Ground">
              <svg viewBox="-10 -2 20 14">
                <path
                  d="M0,0 V8 M-8,8 H8 M-5,11 H5 M-2,14 H2"
                  fill="none"
                  stroke-linecap="round"
                ></path>
              </svg>
            </button>
          </div>
        </div>
      </div>
      <!-- START: Switches  Dropdown -->
      <div class="tool-dropdown">
        <button
          class="tool-btn dropdown-trigger"
          title="Switches & Transistors"
        >
          <svg viewBox="-45 -20 50 40">
            <path
              d="M-40,0 L-30,0 M-8, 0 L10,0 M-30,0 L-8,-18"
              stroke-width="2.5"
              fill="none"
              stroke-linecap="round"
            />
            <circle cx="-30" cy="0" r="4" stroke-width="1.5" fill="white" />
            <circle cx="-8" cy="0" r="4" stroke-width="1.5" fill="white" />
          </svg>
        </button>
        <div class="dropdown-content">
          <button
            class="tool-btn"
            id="tool-switch"
            title="Switch (SPST - Double-click to toggle)"
          >
            <svg viewBox="-45 -20 50 40">
              <path
                d="M-40,0 L-30,0 M-8, 0 L10,0 M-30,0 L-8,-18"
                stroke-width="2.5"
                fill="none"
                stroke-linecap="round"
              />
              <circle cx="-30" cy="0" r="4" stroke-width="1.5" fill="white" />
              <circle cx="-8" cy="0" r="4" stroke-width="1.5" fill="white" />
            </svg>
          </button>
          <button
            class="tool-btn"
            id="tool-spdtSwitch"
            title="2-Way Switch (SPDT - Double-click to toggle)"
          >
            <svg viewBox="-45 -20 50 40">
              <path
                d="M-40,0 L-30,0 M-8, -12 L10,-12 M-8, 12 L10,12 M-30,0 L-8,-18"
                stroke-width="2.5"
                fill="none"
                stroke-linecap="round"
              />
              <circle cx="-30" cy="0" r="4" stroke-width="1.5" fill="white" />
              <circle cx="-8" cy="-12" r="4" stroke-width="1.5" fill="white" />
              <circle cx="-8" cy="12" r="4" stroke-width="1.5" fill="white" />
            </svg>
          </button>
        </div>
      </div>
      <!-- END: Switches & Transistors Dropdown -->
      <div class="divider"></div>
      <div class="tool-group">
        <button class="action-btn" id="undoBtn" title="Undo (Ctrl+Z)">
          <i class="material-icons">undo</i>
        </button>
        <button class="action-btn" id="redoBtn" title="Redo (Ctrl+Y)">
          <i class="material-icons">redo</i>
        </button>
        <button
          class="action-btn"
          id="copyBtn"
          title="Duplicate Selected (Ctrl+D)"
        >
          <i class="material-icons">content_copy</i>
        </button>
        <button class="action-btn" id="rotateBtn" title="Rotate Selected (R)">
          <i class="material-icons">rotate_right</i>
        </button>
        <button class="action-btn" id="deleteBtn" title="Delete Selected (Del)">
          <i class="material-icons">delete</i>
        </button>
      </div>
      <div class="divider"></div>
      <!-- START: Bulk Operations (Moved) -->
      <div class="tool-group">
        <button class="action-btn" id="bulkAddBtn" title="Bulk Add Components">
          <i class="material-icons">playlist_add</i>
        </button>
        <button
          class="action-btn"
          id="bulkTextBtn"
          title="Bulk Add Text Labels"
        >
          <i class="material-icons">format_list_bulleted_add</i>
        </button>
      </div>
      <!-- END: Bulk Operations -->
      <div class="divider"></div>
      <!-- START: File Operations Dropdown (Moved) -->
      <div class="tool-dropdown">
        <button
          id="fileOpsBtn"
          class="action-btn dropdown-trigger"
          title="File Operations"
        >
          <i class="material-icons">save</i>
        </button>
        <div class="dropdown-content">
          <button
            class="action-btn"
            id="saveExportBtn"
            title="Save or Export... (Ctrl+S)"
          >
            <i class="material-icons">save_alt</i>
          </button>
          <button class="action-btn" id="loadBtn" title="Load File (Ctrl+O)">
            <i class="material-symbols-outlined">folder_open</i>
          </button>
          <!-- ===== GEMINI BUTTON START ===== -->
          <button
            class="action-btn"
            id="geminiAIBtn"
            title="Generate Circuit with AI"
          >
            <i class="material-icons">auto_awesome</i>
          </button>
          <!-- ===== GEMINI BUTTON END ===== -->
        </div>
      </div>
      <!-- END: File Operations Dropdown -->
    </div>

    <canvas id="circuitCanvas" width="1000" height="700"></canvas>
    <input type="file" id="fileInput" accept=".json" style="display: none" />

    <!-- START: Bulk Add Components Modal -->
    <div id="bulkAddModal" class="modal-overlay">
      <div class="modal-content">
        <span class="modal-close" id="bulkAddModalClose">&times;</span>
        <h3>Bulk Add Components</h3>
        <p>
          Valid names: R, L, C, D, ZD, LED, SW, SPDT, Vdc, Vac, Idc, DVS, DCS,
          GND, Batt, IGBT, NPN, PNP.
        </p>
        <div class="modal-table-container">
          <table id="bulk-input-table">
            <thead>
              <tr>
                <th>Component Name</th>
                <th>Quantity</th>
                <th>Auto-Label? (Y/N)</th>
                <th></th>
              </tr>
            </thead>
            <tbody>
              <!-- Rows will be added here by JavaScript -->
            </tbody>
          </table>
        </div>
        <button id="add-row-btn" class="modal-button">Add Another Row</button>
        <div class="modal-actions">
          <button id="bulk-cancel-btn" class="modal-button secondary">
            Cancel
          </button>
          <button id="bulk-place-btn" class="modal-button primary">
            Place Components
          </button>
        </div>
      </div>
    </div>
    <!-- END: Bulk Add Components Modal -->

    <!-- START: Bulk Add Text Modal -->
    <div id="bulkTextModal" class="modal-overlay">
      <div class="modal-content">
        <span class="modal-close" id="bulkTextModalClose">&times;</span>
        <h3>Bulk Add Text</h3>
        <p>
          Enter text labels separated by a semicolon (;), OR paste a full
          circuit JSON to append it below the current drawing.
        </p>
        <textarea
          id="bulk-text-input"
          placeholder="Label 1; Label 2; V_in = 5V; ..."
        ></textarea>
        <div class="modal-actions">
          <button id="bulk-text-cancel-btn" class="modal-button secondary">
            Cancel
          </button>
          <button id="bulk-text-place-btn" class="modal-button primary">
            Place Text
          </button>
        </div>
      </div>
    </div>
    <!-- END: Bulk Add Text Modal -->

    <!-- START: Text Input Modal -->
    <div id="textInputModal" class="modal-overlay">
      <div class="modal-content">
        <span class="modal-close" id="textInputModalClose">&times;</span>
        <h3>Add / Edit Text Label</h3>
        <p>Use LaTeX style: V_{in}, R^2, \frac{num}{den}, \mu, etc.</p>
        <p>
          Wrap math expression inside &...& to evaluate the numerical value:
          &(1/15)+8**2&.
        </p>
        <textarea
          id="text-input-area"
          placeholder="Enter text here..."
        ></textarea>
        <div class="text-modal-options">
          <label>
            <input type="checkbox" id="text-italic-checkbox" checked />
            <span>Use Italic Font</span>
          </label>
        </div>
        <div class="modal-actions">
          <button id="text-modal-cancel-btn" class="modal-button secondary">
            Cancel
          </button>
          <button id="text-modal-ok-btn" class="modal-button primary">
            OK
          </button>
        </div>
      </div>
    </div>
    <!-- END: Text Input Modal -->

    <script>
      /****************************************************************************
       * Circuit Drafter - V0.40aR (Date: 2025-08-05)
       *   - Add NPN PNP and IGBT
       *   - Add draw by AI button
       * Circuit Drafter - V0.32R (Date: 2025-07-24)
       *   - Math expression can be evaluated inside &.....&
       *  - Add \times for multiply symbol.
       *   - Add dependent sources.
       *  - Double click component to direct edit rotation value.
       *  - Change color from black to red by Alt+C
       *  - Change design of the inductor !!!
       * Circuit Drafter - V0.32e (Date: 2025-07-21)
       *  - Add SPDT
       *  - Text font can be italic or normal.
       *  - Add small red arrow marker with Alt+Click.
       * Circuit Drafter - V0.32b (Date: 2025-07-20)
       * SUMMARY OF CHANGES FROM V0.28a:
       * - UI Overhaul: Grouped R/L/C components and reorganized the toolbar.
       * - Bulk Placement: Added "Bulk Add Components" via a table modal.
       * - Bulk Text: Added "Bulk Add Text" via a semicolon-delimited input.
       * - Smart Canvas: Implemented dynamic canvas resizing to prevent
       *   off-screen placement of bulk-added elements.
       * - Bug Fixes: Corrected diode/zener/led selection boxes and ensured
       *   auto-labels are always capitalized.
       * - Text Engine Upgrade: Added support for LaTeX-style grouped
       *   subscripts/superscripts (e.g., V_{in}) and fractions (\frac{}{}).
       *   Fixed fraction rendering with subscripts in the numerator.
       * - Able to append json circuit file to the current drawing via Bulk text input.
       ****************************************************************************/
      /**
       * Handles the placement of elements from the "Bulk Add Text" modal.
       * This function serves a dual purpose based on the user's input:
       *
       * 1.  **JSON Append Mode:** If the input text appears to be a valid Circuit Drafter
       *     JSON object, this function will append the entire circuit from the JSON to
       *     the canvas below the currently existing drawing. It intelligently recalculates
       *     all coordinates and assigns new IDs to prevent conflicts.
       *
       * 2.  **Text Label Mode:** If the input is not a valid circuit JSON, it falls
       *     back to its original behavior of treating the input as a list of text
       *     labels separated by semicolons, placing each one on the canvas.
       *
       * The JSON Append logic follows these steps:
       *   1.  Calculate the vertical offset required by finding the bottom-most point
       *       (maxY) of the current circuit and adding a padding.
       *   2.  Iterate through each element in the pasted JSON data. For each element:
       *       a. Assign a new, unique ID from the current project's `nextId` counter.
       *       b. Recalculate its Y-coordinate(s) by adding the vertical offset.
       *   3.  Push the newly processed and re-coordinated elements into the main
       *       `circuitElements` array.
       *   4.  Resize the canvas to ensure it is large enough to fit the entire combined
       *       drawing.
       *   5.  Save the new state to the history and redraw the canvas.
       */
      document.addEventListener("DOMContentLoaded", () => {
        let canvas = document.getElementById("circuitCanvas");
        let ctx = canvas.getContext("2d");
        const fileInput = document.getElementById("fileInput");

        // START: Bulk Components Modal Variables
        const bulkAddBtn = document.getElementById("bulkAddBtn");
        const bulkAddModal = document.getElementById("bulkAddModal");
        const bulkAddModalClose = document.getElementById("bulkAddModalClose");
        const addRowBtn = document.getElementById("add-row-btn");
        const bulkPlaceBtn = document.getElementById("bulk-place-btn");
        const bulkCancelBtn = document.getElementById("bulk-cancel-btn");
        const bulkInputTableBody = document.querySelector(
          "#bulk-input-table tbody"
        );

        // START: Bulk Text Modal Variables
        const bulkTextBtn = document.getElementById("bulkTextBtn");
        const bulkTextModal = document.getElementById("bulkTextModal");
        const bulkTextModalClose =
          document.getElementById("bulkTextModalClose");
        const bulkTextInput = document.getElementById("bulk-text-input");
        const bulkTextPlaceBtn = document.getElementById("bulk-text-place-btn");
        const bulkTextCancelBtn = document.getElementById(
          "bulk-text-cancel-btn"
        );

        // START: New Text Input Modal Variables
        const textInputModal = document.getElementById("textInputModal");
        const textInputModalClose = document.getElementById(
          "textInputModalClose"
        );
        const textInputArea = document.getElementById("text-input-area");
        const textItalicCheckbox = document.getElementById(
          "text-italic-checkbox"
        );
        const textModalOkBtn = document.getElementById("text-modal-ok-btn");
        const textModalCancelBtn = document.getElementById(
          "text-modal-cancel-btn"
        );

        // ===== GEMINI AI BUTTON START =====
        const geminiAIBtn = document.getElementById("geminiAIBtn");
        // ===== GEMINI AI BUTTON END =====

        let autoLabelCounters = {};
        const shortNameToType = {
          R: "resistor",
          L: "inductor",
          C: "capacitor",
          D: "diode",
          ZD: "zener",
          LED: "led",
          FWD: "fwd",
          SW: "switch",
          SPDT: "spdtSwitch",
          IGBT: "igbt",
          NFET: "nfet",
          PFET: "pfet",
          NPN: "npn",
          PNP: "pnp",
          VDC: "voltage",
          VAC: "acvoltage",
          IDC: "currentsource",
          DVS: "dependent_voltage",
          DCS: "dependent_current",
          GND: "gnd",
          BATT: "battery",
          ARROW: "arrow_marker",
        };
        const shortNameToTypeCI = Object.keys(shortNameToType).reduce(
          (acc, key) => {
            acc[key.toUpperCase()] = shortNameToType[key];
            return acc;
          },
          {}
        );

        let selectedTool = "select";
        let isDrawingWire = false,
          isDragging = false,
          isShiftDown = false;
        let wireStartPoint = null,
          currentMousePos = { x: 0, y: 0 },
          dragStartPoint = null;
        let circuitElements = [];
        let nextId = 0;
        const gridSize = 20,
          snapTolerance = 12,
          textFontSize = 16;
        const fineGridSize = gridSize / 8; // <-- ADD THIS LINE (5px grid)
        let history = [],
          historyIndex = -1;

        let selectedElements = [];
        let isMarqueeSelecting = false;
        let marqueeStartPoint = null;
        let hoveredWireSegment = null;

        const componentData = {
          resistor: {
            width: 80,
            height: 30,
            terminals: [
              { x: -40, y: 0 },
              { x: 40, y: 0 },
            ],
          },
          capacitor: {
            width: 80,
            height: 30,
            terminals: [
              { x: -40, y: 0 },
              { x: 40, y: 0 },
            ],
          },
          inductor: {
            width: 80,
            height: 30,
            terminals: [
              { x: -40, y: 0 },
              { x: 40, y: 0 },
            ],
          },
          diode: {
            width: 60,
            height: 30,
            terminals: [
              { x: -30, y: 0 },
              { x: 30, y: 0 },
            ],
          },
          fwd: {
            width: 60,
            height: 30,
            terminals: [
              { x: -30, y: 0 },
              { x: 30, y: 0 },
            ],
          },
          zener: {
            width: 60,
            height: 34,
            terminals: [
              { x: -30, y: 0 },
              { x: 30, y: 0 },
            ],
          },
          led: {
            width: 60,
            height: 50,
            terminals: [
              { x: -30, y: 0 },
              { x: 30, y: 0 },
            ],
          },
          switch: {
            width: 80,
            height: 30,
            terminals: [
              { x: -40, y: 0 },
              { x: 40, y: 0 },
            ],
          },
          spdtSwitch: {
            width: 80,
            height: 60,
            terminals: [
              { x: -40, y: 0 }, // common
              { x: 40, y: -20 }, // throw 1
              { x: 40, y: 20 }, // throw 2
            ],
          },
          igbt: {
            width: 60,
            height: 105,
            terminals: [
              { x: 70, y: 0 }, // Collector
              { x: 70, y: 105 }, // Emitter
              { x: 0, y: 65 }, // Gate
            ],
          },
          nfet: {
            width: 60,
            height: 105,
            terminals: [
              { x: 70, y: 0 }, // Drain
              { x: 70, y: 105 }, // Source
              { x: 0, y: 65 }, // Gate
            ],
          },
          pfet: {
            width: 60,
            height: 105,
            terminals: [
              { x: 70, y: 0 }, // Drain
              { x: 70, y: 105 }, // Source
              { x: 0, y: 65 }, // Gate
            ],
          },
          npn: {
            width: 60,
            height: 105,
            terminals: [
              { x: 70, y: 0 }, // Collector
              { x: 70, y: 105 }, // Emitter
              { x: 0, y: 65 }, // Base
            ],
          },
          pnp: {
            width: 60,
            height: 105,
            terminals: [
              { x: 70, y: 0 }, // Emitter
              { x: 70, y: 105 }, // Collector
              { x: 0, y: 65 }, // Base
            ],
          },
          voltage: {
            width: 60,
            height: 60,
            terminals: [
              { x: 0, y: -30 },
              { x: 0, y: 30 },
            ],
          },
          acvoltage: {
            width: 60,
            height: 60,
            terminals: [
              { x: 0, y: -30 },
              { x: 0, y: 30 },
            ],
          },
          currentsource: {
            width: 60,
            height: 60,
            terminals: [
              { x: 0, y: -30 },
              { x: 0, y: 30 },
            ],
          },
          dependent_voltage: {
            width: 60,
            height: 60,
            terminals: [
              { x: 0, y: -30 },
              { x: 0, y: 30 },
            ],
          },
          dependent_current: {
            width: 60,
            height: 60,
            terminals: [
              { x: 0, y: -30 },
              { x: 0, y: 30 },
            ],
          },
          battery: {
            width: 40,
            height: 60,
            terminals: [
              { x: 0, y: -30 },
              { x: 0, y: 30 },
            ],
          },
          gnd: { width: 30, height: 20, terminals: [{ x: 0, y: -10 }] },
          arrow_marker: {
            width: 16,
            height: 10,
            terminals: [],
          },
        };

        const actionButtons = {
          undo: document.getElementById("undoBtn"),
          redo: document.getElementById("redoBtn"),
          copy: document.getElementById("copyBtn"),
          rotate: document.getElementById("rotateBtn"),
          delete: document.getElementById("deleteBtn"),
        };

        function updateToolbar() {
          document
            .querySelectorAll(".tool-btn, .action-btn")
            .forEach((btn) => btn.classList.remove("selected"));
          const currentToolButton = document.getElementById(
            `tool-${selectedTool}`
          );
          if (currentToolButton) {
            currentToolButton.classList.add("selected");
            const parentDropdown = currentToolButton.closest(".tool-dropdown");
            if (parentDropdown)
              parentDropdown
                .querySelector(".dropdown-trigger")
                .classList.add("selected");
          }
          actionButtons.undo.disabled = historyIndex <= 0;
          actionButtons.redo.disabled = historyIndex >= history.length - 1;
          const isComponentSelected = selectedElements.some(
            (el) =>
              el.type !== "wire" &&
              el.type !== "text" &&
              el.type !== "junction" &&
              el.type !== "open_terminal"
          );
          actionButtons.rotate.disabled = !isComponentSelected;
          actionButtons.copy.disabled = selectedElements.length === 0;
          actionButtons.delete.disabled = selectedElements.length === 0;
          canvas.style.cursor =
            selectedTool === "select" ? "default" : "crosshair";
        }

        document.getElementById("toolbar").addEventListener("click", (e) => {
          const target = e.target.closest("button");
          if (!target || target.disabled) return;
          if (
            target.classList.contains("tool-btn") &&
            !target.classList.contains("dropdown-trigger")
          ) {
            selectedTool = target.id.replace("tool-", "");
            if (selectedTool !== "select") selectedElements = [];
          } else if (target.id === "undoBtn") undo();
          else if (target.id === "redoBtn") redo();
          else if (target.id === "copyBtn") copySelected();
          else if (target.id === "rotateBtn") rotateSelected();
          else if (target.id === "deleteBtn") deleteSelected();
          else if (target.id === "saveExportBtn") handleSaveExport();
          else if (target.id === "loadBtn") fileInput.click();
          redrawCanvas();
        });

        window.addEventListener("keydown", (e) => {
          if (
            document.activeElement.tagName === "INPUT" ||
            document.activeElement.tagName === "TEXTAREA"
          )
            return;
          if (e.key === "Shift") isShiftDown = true;
          // NEW: Add this block for Alt+R
          else if (e.altKey && e.key.toLowerCase() === "c") {
            e.preventDefault();
            if (selectedElements.length > 0) {
              selectedElements.forEach((el) => {
                // Toggle the color property
                if (el.color === "red") {
                  delete el.color; // Revert to default (black)
                } else {
                  el.color = "red";
                }
              });
              saveState(); // Save the change to history
              redrawCanvas();
            }
          }
          // END of new block

          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            switch (e.key.toLowerCase()) {
              case "z":
                undo();
                break;
              case "y":
                redo();
                break;
              case "d":
                copySelected();
                break;
              case "s":
                handleSaveExport();
                break;
              case "o":
                fileInput.click();
                break;
            }
          } else {
            switch (e.key.toLowerCase()) {
              case "r":
                if (selectedElements.length > 0) {
                  e.preventDefault();
                  rotateSelected();
                }
                break;
              case "delete":
              case "backspace":
                if (selectedElements.length > 0) {
                  e.preventDefault();
                  deleteSelected();
                }
                break;
              case "w":
                selectedTool = "wire";
                break;
              case "s":
                selectedTool = "select";
                break;
              case "t":
                selectedTool = "text";
                break;
            }
          }
          redrawCanvas();
        });

        window.addEventListener("keyup", (e) => {
          if (e.key === "Shift") {
            isShiftDown = false;
            redrawCanvas();
          }
        });
        window.addEventListener("blur", () => {
          isShiftDown = false;
        });
        fileInput.addEventListener("change", handleFileLoad);

        // START: Modal Event Listeners
        bulkAddBtn.addEventListener("click", openBulkAddModal);
        bulkAddModalClose.addEventListener("click", closeBulkAddModal);
        bulkCancelBtn.addEventListener("click", closeBulkAddModal);
        addRowBtn.addEventListener("click", () => addBulkRow());
        bulkPlaceBtn.addEventListener("click", handleBulkPlace);
        bulkInputTableBody.addEventListener("click", (e) => {
          if (e.target.classList.contains("delete-row-btn")) {
            e.target.closest("tr").remove();
          }
        });

        bulkTextBtn.addEventListener("click", openBulkTextModal);
        bulkTextModalClose.addEventListener("click", closeBulkTextModal);
        bulkTextCancelBtn.addEventListener("click", closeBulkTextModal);
        bulkTextPlaceBtn.addEventListener("click", handleBulkTextPlace);

        window.addEventListener("click", (event) => {
          if (event.target == bulkAddModal) {
            closeBulkAddModal();
          }
          if (event.target == bulkTextModal) {
            closeBulkTextModal();
          }
          if (event.target == textInputModal) {
            // This is handled by the promise-based function's cancel logic
          }
        });
        // END: Modal Event Listeners

        function saveState() {
          history = history.slice(0, historyIndex + 1);
          const cleanState = JSON.parse(
            JSON.stringify(circuitElements, (key, value) =>
              key === "dragInitialState" ? undefined : value
            )
          );
          history.push(cleanState);
          historyIndex++;
          updateToolbar();
        }
        function undo() {
          if (historyIndex > 0) {
            historyIndex--;
            setState();
          }
        }
        function redo() {
          if (historyIndex < history.length - 1) {
            historyIndex++;
            setState();
          }
        }
        function setState() {
          circuitElements = JSON.parse(JSON.stringify(history[historyIndex]));
          selectedElements = [];
          redrawCanvas();
        }
        function copySelected() {
          if (selectedElements.length === 0) return;
          const newSelection = [];
          selectedElements.forEach((el) => {
            const newEl = JSON.parse(JSON.stringify(el));
            newEl.id = nextId++;
            if (newEl.type === "wire") {
              newEl.start.x += gridSize;
              newEl.start.y += gridSize;
              newEl.end.x += gridSize;
              newEl.end.y += gridSize;
            } else {
              newEl.x += gridSize;
              newEl.y += gridSize;
            }
            circuitElements.push(newEl);
            newSelection.push(newEl);
          });
          selectedElements = newSelection;
          saveState();
          redrawCanvas();
        }
        function rotateSelected() {
          if (selectedElements.length === 0) return;
          selectedElements.forEach((el) => {
            if (
              el.type !== "wire" &&
              el.type !== "text" &&
              el.type !== "junction" &&
              el.type !== "open_terminal"
            ) {
              el.rotation = (el.rotation + 45) % 360;
            }
          });
          saveState();
          redrawCanvas();
        }
        function deleteSelected() {
          if (selectedElements.length === 0) return;
          const selectedIds = new Set(selectedElements.map((el) => el.id));
          circuitElements = circuitElements.filter(
            (el) => !selectedIds.has(el.id)
          );
          selectedElements = [];
          saveState();
          redrawCanvas();
        }

        function redrawCanvas() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawGrid();
          circuitElements.forEach((el) => drawElement(el));
          if (hoveredWireSegment) {
            ctx.save();
            ctx.strokeStyle = "#007bff";
            ctx.lineWidth = 4;
            ctx.shadowColor = "rgba(0, 123, 255, 0.7)";
            ctx.shadowBlur = 8;
            ctx.lineCap = "round";
            ctx.beginPath();
            ctx.moveTo(hoveredWireSegment.p1.x, hoveredWireSegment.p1.y);
            ctx.lineTo(hoveredWireSegment.p2.x, hoveredWireSegment.p2.y);
            ctx.stroke();
            ctx.restore();
          }
          drawJunctions();
          drawSelection();
          if (isDrawingWire && wireStartPoint) {
            let endPoint = getSnappingPoint(
              currentMousePos.x,
              currentMousePos.y
            );
            drawWirePreview(wireStartPoint, endPoint);
            drawSnapIndicator(endPoint);
          } else if (selectedTool === "wire") {
            const snapPoint = getSnappingPoint(
              currentMousePos.x,
              currentMousePos.y
            );
            drawSnapIndicator(snapPoint);
          }
          if (isMarqueeSelecting && marqueeStartPoint) {
            drawMarquee(marqueeStartPoint, currentMousePos);
          }
          updateToolbar();
        }

        // --- START: Bulk Add/Text Functions ---

        function resizeCanvas(newWidth, newHeight) {
          if (canvas.width >= newWidth && canvas.height >= newHeight) return;

          const finalWidth = Math.max(canvas.width, newWidth);
          const finalHeight = Math.max(canvas.height, newHeight);

          canvas.width = finalWidth;
          canvas.height = finalHeight;

          redrawCanvas();
        }

        function addBulkRow(name = "", qty = 1, label = "Y") {
          const row = document.createElement("tr");
          row.innerHTML = `
                <td><input type="text" class="comp-name" placeholder="e.g., R, C, SPDT" value="${name}"></td>
                <td><input type="number" class="comp-qty" min="1" value="${qty}"></td>
                <td><input type="text" class="comp-label" placeholder="Y or N" value="${label}" maxlength="1"></td>
                <td><button class="delete-row-btn">&times;</button></td>
            `;
          bulkInputTableBody.appendChild(row);
        }

        function openBulkAddModal() {
          bulkInputTableBody.innerHTML = "";
          addBulkRow();
          bulkAddModal.style.display = "flex";
        }

        function closeBulkAddModal() {
          bulkAddModal.style.display = "none";
        }

        function openBulkTextModal() {
          bulkTextInput.value = "";
          bulkTextModal.style.display = "flex";
        }

        function closeBulkTextModal() {
          bulkTextModal.style.display = "none";
        }

        function recalculateAutoLabelCounters() {
          autoLabelCounters = {};
          // Updated regex to handle both "R1" and "R_{1}" formats
          const labelRegex = /^([A-Z_a-z]+)(?:_\{)?(\d+)\}?$/i;

          circuitElements.forEach((el) => {
            if (el.type === "text" && el.text) {
              const match = el.text.match(labelRegex);
              if (match) {
                const prefix = match[1].toUpperCase();
                const num = parseInt(match[2], 10);
                if (
                  !autoLabelCounters[prefix] ||
                  num >= autoLabelCounters[prefix]
                ) {
                  autoLabelCounters[prefix] = num + 1;
                }
              }
            }
          });
        }

        function handleBulkPlace() {
          recalculateAutoLabelCounters();
          const rows = bulkInputTableBody.querySelectorAll("tr");
          const placeStepX = 150;
          const placeStepY = 120;
          const placementMargin = 100;
          const requests = [];
          let totalComponentCount = 0;

          for (const row of rows) {
            const nameInput = row.querySelector(".comp-name");
            const qtyInput = row.querySelector(".comp-qty");
            const labelInput = row.querySelector(".comp-label");
            const shortNameRaw = nameInput.value.trim();
            if (!shortNameRaw) continue;

            const shortName = shortNameRaw.toUpperCase();
            const quantity = parseInt(qtyInput.value, 10);
            const autoLabel = labelInput.value.trim().toUpperCase();
            const componentType = shortNameToTypeCI[shortName];

            if (!componentType) {
              alert(`Invalid component name: "${nameInput.value}".`);
              nameInput.focus();
              return;
            }
            if (isNaN(quantity) || quantity < 1) {
              alert(`Invalid quantity: "${qtyInput.value}".`);
              qtyInput.focus();
              return;
            }
            requests.push({
              shortNameRaw,
              shortName,
              quantity,
              autoLabel,
              componentType,
            });
            totalComponentCount += quantity;
          }

          if (totalComponentCount === 0) {
            closeBulkAddModal();
            return;
          }

          const bounds = calculateBoundingBox();
          const placementStart = {
            x: placementMargin,
            y: bounds
              ? Math.floor((bounds.maxY + placementMargin) / gridSize) *
                gridSize
              : placementMargin,
          };

          const componentsPerRow = Math.max(
            1,
            Math.floor((canvas.width - placementMargin * 2) / placeStepX)
          );
          const requiredRows = Math.ceil(
            totalComponentCount / componentsPerRow
          );

          const requiredWidth =
            placementStart.x +
            Math.min(totalComponentCount, componentsPerRow) * placeStepX;
          const requiredHeight = placementStart.y + requiredRows * placeStepY;

          resizeCanvas(requiredWidth, requiredHeight);

          let placeX = placementStart.x;
          let placeY = placementStart.y;
          const componentsToAdd = [];

          for (const req of requests) {
            for (let i = 0; i < req.quantity; i++) {
              const newComp = {
                id: nextId++,
                type: req.componentType,
                x: placeX,
                y: placeY,
                rotation: 0,
              };
              if (newComp.type === "switch") {
                newComp.state = "open";
              }
              if (newComp.type === "spdtSwitch") {
                newComp.state = 1;
              }
              componentsToAdd.push(newComp);

              if (req.autoLabel === "Y") {
                if (!autoLabelCounters[req.shortName])
                  autoLabelCounters[req.shortName] = 1;
                // Use LaTeX-style subscript for the auto-generated number
                const labelText =
                  req.shortName +
                  "_{" +
                  autoLabelCounters[req.shortName]++ +
                  "}";
                const newLabel = {
                  id: nextId++,
                  type: "text",
                  text: labelText,
                  x: placeX,
                  y: placeY + 45,
                  rotation: 0,
                  isItalic: true,
                };
                componentsToAdd.push(newLabel);
              }

              placeX += placeStepX;
              if (placeX > canvas.width - placementMargin) {
                placeX = placementStart.x;
                placeY += placeStepY;
              }
            }
          }

          if (componentsToAdd.length > 0) {
            circuitElements.push(...componentsToAdd);
            saveState();
            redrawCanvas();
          }

          closeBulkAddModal();
        }

        function handleBulkTextPlace() {
          const rawText = bulkTextInput.value.trim();
          if (!rawText) {
            closeBulkTextModal();
            return;
          }

          // Check if the input is a JSON object to append.
          if (rawText.startsWith("{") && rawText.endsWith("}")) {
            if (
              appendCircuitFromJSON(
                rawText,
                "Circuit appended successfully from text!"
              )
            ) {
              closeBulkTextModal();
            }
            return;
          }

          // If not JSON, proceed with original text-adding logic.
          const textItems = rawText
            .split(";")
            .map((item) => item.trim())
            .filter((item) => item.length > 0);
          if (textItems.length === 0) {
            closeBulkTextModal();
            return;
          }

          const verticalSpacing = 40;
          const placementMargin = 100;
          const bounds = calculateBoundingBox();

          const placementStart = {
            x: placementMargin,
            y: bounds
              ? Math.floor((bounds.maxY + 80) / gridSize) * gridSize
              : 80,
          };

          const requiredHeight =
            placementStart.y + textItems.length * verticalSpacing;
          resizeCanvas(canvas.width, requiredHeight);

          let placeY = placementStart.y;
          const textsToAdd = [];

          textItems.forEach((item) => {
            const processedItem = evaluateExpressions(item);
            const newText = {
              id: nextId++,
              type: "text",
              text: processedItem,
              x: placementStart.x,
              y: placeY,
              rotation: 0,
              isItalic: true,
            };
            textsToAdd.push(newText);
            placeY += verticalSpacing;
          });

          if (textsToAdd.length > 0) {
            circuitElements.push(...textsToAdd);
            saveState();
            redrawCanvas();
          }

          closeBulkTextModal();
        } // --- END: Bulk Add/Text Functions ---

        // --- START: Text Input Modal Function ---
        function showTextInputModal(initialText = "", initialItalic = true) {
          return new Promise((resolve, reject) => {
            textInputArea.value = initialText;
            textItalicCheckbox.checked = initialItalic;
            textInputModal.style.display = "flex";
            textInputArea.focus();
            textInputArea.select();

            const onOk = () => {
              cleanup();
              // Evaluate expressions like &(1+1)& before resolving
              const processedText = evaluateExpressions(textInputArea.value);
              resolve({
                text: processedText,
                isItalic: textItalicCheckbox.checked,
              });
            };

            const onCancel = () => {
              cleanup();
              reject();
            };

            const cleanup = () => {
              textModalOkBtn.removeEventListener("click", onOk);
              textModalCancelBtn.removeEventListener("click", onCancel);
              textInputModalClose.removeEventListener("click", onCancel);
              window.removeEventListener("keydown", onKeydown);
              textInputModal.style.display = "none";
            };

            const onKeydown = (e) => {
              if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) {
                onOk();
              } else if (e.key === "Escape") {
                onCancel();
              }
            };

            textModalOkBtn.addEventListener("click", onOk, { once: true });
            textModalCancelBtn.addEventListener("click", onCancel, {
              once: true,
            });
            textInputModalClose.addEventListener("click", onCancel, {
              once: true,
            });
            window.addEventListener("keydown", onKeydown);
          });
        }
        // --- END: Text Input Modal Function ---

        // ... (code for measureParsedText, drawRecursive, drawText ends here)

        // ***************************************************************
        // END: NEW RECURSIVE TEXT PARSING, MEASURING, AND DRAWING ENGINE
        // ***************************************************************

        // START: INSERT THIS NEW FUNCTION HERE
        /**
         * Finds and evaluates mathematical expressions enclosed in &...&.
         * Example: "&(1/2000+1/1000)&" becomes "1.5e-3".
         * Uses a safe Function constructor for evaluation.
         * @param {string} text The input string.
         * @returns {string} The string with expressions replaced by their values.
         */
        function evaluateExpressions(text) {
          if (!text || !text.includes("&")) {
            return text;
          }

          // Regex to find content between &...& non-greedily
          const regex = /&(.+?)&/g;

          return text.replace(regex, (match, expression) => {
            try {
              // Use the Function constructor for safer evaluation than eval().
              // It runs in its own scope, preventing access to local variables.
              const result = new Function("return " + expression)();

              if (typeof result !== "number" || !isFinite(result)) {
                return match; // Not a number, return original string
              }

              // Use exponential notation for very large or very small numbers
              if (
                Math.abs(result) > 1e6 ||
                (Math.abs(result) < 1e-6 && result !== 0)
              ) {
                // toExponential() gives the format "1.5e-3" as requested
                return result.toExponential(6);
              }

              // For other numbers, prevent long floating point representations
              return parseFloat(result.toPrecision(6)).toString();
            } catch (e) {
              // If evaluation fails (e.g., syntax error like "&hello&"),
              // log the error and return the original text so the app doesn't break.
              console.warn(
                `Could not evaluate expression: ${match}`,
                e.message
              );
              return match;
            }
          });
        }
        // END: INSERT THIS NEW FUNCTION HERE

        function drawElement(el, isSelected = false) {
          ctx.save();
          setDrawingStyle(isSelected, el.color); // <-- MODIFY THIS LINE
          if (el.type === "wire") {
            drawWire(el, isSelected);
          } else if (el.type === "text") {
            drawText(el, isSelected);
          } // NOTE: Removed translate for text, handled in drawText
          else {
            ctx.translate(el.x, el.y);
            ctx.rotate((el.rotation * Math.PI) / 180);
            switch (el.type) {
              case "resistor":
                drawResistor();
                break;
              case "capacitor":
                drawCapacitor();
                break;
              case "inductor":
                drawInductor();
                break;
              case "diode":
                drawDiode();
                break;
              case "fwd":
                drawFWD();
                break;
              case "zener":
                drawZenerDiode();
                break;
              case "led":
                drawLED();
                break;
              case "switch":
                drawSwitch(el);
                break;
              case "spdtSwitch":
                drawSpdtSwitch(el);
                break;
              case "igbt":
                drawIGBT();
                break;
              case "nfet":
                drawNFET();
                break;
              case "pfet":
                drawPFET();
                break;
              case "npn":
                drawNPN();
                break;
              case "pnp":
                drawPNP();
                break;
              case "voltage":
                drawVoltageSource();
                break;
              case "acvoltage":
                drawACVoltageSource();
                break;
              case "currentsource":
                drawCurrentSource();
                break;
              case "dependent_voltage":
                drawDependentVoltageSource();
                break;
              case "dependent_current":
                drawDependentCurrentSource();
                break;
              case "battery":
                drawBattery();
                break;
              case "gnd":
                drawGround();
                break;
              case "arrow_marker":
                drawArrowMarker(el);
                break;
              case "junction":
                drawManualJunction();
                break;
              case "open_terminal":
                drawOpenTerminal();
                break;
            }
          }
          ctx.restore();
        }
        function setDrawingStyle(isSelected = false, color = "black") {
          // If a color is passed (e.g., 'red'), use it. Otherwise, default to black.
          const finalColor = color || "black";

          // Use blue for selection, otherwise use the component's color.
          ctx.strokeStyle = isSelected ? "#007bff" : finalColor;
          ctx.fillStyle = isSelected ? "#007bff" : finalColor;

          ctx.lineWidth = isSelected ? 2.5 : 2;
          ctx.lineCap = "round";
        }

        function handleMouseDown(e) {
          const mousePos = getMousePos(e);

          if (e.altKey) {
            e.preventDefault();
            const newArrow = {
              id: nextId++,
              type: "arrow_marker",
              x: snapToGrid(mousePos.x),
              y: snapToGrid(mousePos.y),
              rotation: 0,
              color: "black",
            };
            circuitElements.push(newArrow);
            saveState();
            redrawCanvas();
            return;
          }

          if (e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            const newJunction = {
              id: nextId++,
              type: "junction",
              x: snapToGrid(mousePos.x),
              y: snapToGrid(mousePos.y),
              rotation: 0,
            };
            circuitElements.push(newJunction);
            saveState();
            redrawCanvas();
            return;
          }

          let needsStateSave = false;
          if (selectedTool === "select") {
            const clickedElement = getElementAtPos(mousePos.x, mousePos.y);
            if (clickedElement) {
              isMarqueeSelecting = false;
              isDragging = true;
              dragStartPoint = mousePos;
              if (!selectedElements.some((el) => el.id === clickedElement.id)) {
                selectedElements = [clickedElement];
              }
              selectedElements.forEach((el) => {
                el.dragInitialState = {
                  x: el.x,
                  y: el.y,
                  start: el.start ? { ...el.start } : undefined,
                  end: el.end ? { ...el.end } : undefined,
                };
              });
            } else {
              isMarqueeSelecting = true;
              isDragging = false;
              marqueeStartPoint = mousePos;
              selectedElements = [];
            }
          } else if (selectedTool === "wire") {
            isDrawingWire = true;
            wireStartPoint = getSnappingPoint(mousePos.x, mousePos.y);
          } else if (selectedTool === "text") {
            showTextInputModal(
              "V_{out} = V_{in} \\frac{R_2}{R_1+R_2}", // Default text
              true // Default italic
            )
              .then(({ text, isItalic }) => {
                if (text) {
                  // only add if text is not empty
                  const newEl = {
                    id: nextId++,
                    type: "text",
                    text: text,
                    x: snapToGrid(mousePos.x),
                    y: snapToGrid(mousePos.y),
                    rotation: 0,
                    isItalic: isItalic,
                  };
                  circuitElements.push(newEl);
                  selectedTool = "select";
                  selectedElements = [newEl];
                  saveState();
                  redrawCanvas();
                } else {
                  selectedTool = "select";
                  redrawCanvas();
                }
              })
              .catch(() => {
                // User cancelled
                selectedTool = "select";
                redrawCanvas();
              });
            return; // Return early, let the promise handle state changes
          } else {
            const newEl = {
              id: nextId++,
              type: selectedTool,
              x: snapToGrid(mousePos.x),
              y: snapToGrid(mousePos.y),
              rotation: 0,
            };
            if (newEl.type === "switch") {
              newEl.state = "open";
            }
            if (newEl.type === "spdtSwitch") {
              newEl.state = 1;
            }
            circuitElements.push(newEl);
            selectedTool = "select";
            selectedElements = [newEl];
            needsStateSave = true;
          }
          if (needsStateSave) saveState();
          redrawCanvas();
        }

        function updateHoveredWireSegment() {
          if (selectedTool !== "wire") {
            hoveredWireSegment = null;
            return;
          }
          hoveredWireSegment = null;
          for (const wire of circuitElements) {
            if (wire.type !== "wire") continue;
            const path = getWirePath(wire);
            for (let i = 0; i < path.length - 1; i++) {
              const p1 = path[i];
              const p2 = path[i + 1];
              if (distToSegment(currentMousePos, p1, p2) < snapTolerance) {
                hoveredWireSegment = { p1, p2 };
                return;
              }
            }
          }
        }

        function handleMouseMove(e) {
          currentMousePos = getMousePos(e);
          if (isDragging && selectedElements.length > 0 && dragStartPoint) {
            const dx = currentMousePos.x - dragStartPoint.x,
              dy = currentMousePos.y - dragStartPoint.y;
            selectedElements.forEach((el) => {
              const initialState = el.dragInitialState;
              if (!initialState) return;
              if (el.type === "wire") {
                if (initialState.start && initialState.end) {
                  el.start.x = snapToGrid(initialState.start.x + dx);
                  el.start.y = snapToGrid(initialState.start.y + dy);
                  el.end.x = snapToGrid(initialState.end.x + dx);
                  el.end.y = snapToGrid(initialState.end.y + dy);
                }
              } else {
                if (
                  initialState.x !== undefined &&
                  initialState.y !== undefined
                ) {
                  el.x = snapToGrid(initialState.x + dx);
                  el.y = snapToGrid(initialState.y + dy);
                }
              }
            });
          }
          updateHoveredWireSegment();
          redrawCanvas();
        }

        function handleMouseUp(e) {
          let needsStateSave = false;
          if (isMarqueeSelecting) {
            const rect = {
              x1: Math.min(marqueeStartPoint.x, currentMousePos.x),
              y1: Math.min(marqueeStartPoint.y, currentMousePos.y),
              x2: Math.max(marqueeStartPoint.x, currentMousePos.x),
              y2: Math.max(marqueeStartPoint.y, currentMousePos.y),
            };
            selectedElements = circuitElements.filter((el) =>
              isElementInRect(el, rect)
            );
          }
          if (isDrawingWire) {
            const endPoint = getSnappingPoint(
              currentMousePos.x,
              currentMousePos.y
            );
            if (
              Math.hypot(
                endPoint.x - wireStartPoint.x,
                endPoint.y - wireStartPoint.y
              ) > 0
            ) {
              circuitElements.push({
                id: nextId++,
                type: "wire",
                start: wireStartPoint,
                end: endPoint,
                routing: isShiftDown ? "direct" : "manhattan",
              });
              needsStateSave = true;
            }
          }
          if (isDragging) {
            needsStateSave = true;
          }
          isDrawingWire = false;
          isDragging = false;
          isMarqueeSelecting = false;
          marqueeStartPoint = null;
          dragStartPoint = null;
          circuitElements.forEach((el) => delete el.dragInitialState);
          if (needsStateSave) saveState();
          redrawCanvas();
        }

        function handleDoubleClick(e) {
          e.preventDefault();
          const mousePos = getMousePos(e);
          const clickedElement = getElementAtPos(mousePos.x, mousePos.y);

          // If we didn't click on any element, create an open terminal as before.
          if (!clickedElement) {
            const newTerminal = {
              id: nextId++,
              type: "open_terminal",
              x: snapToGrid(mousePos.x),
              y: snapToGrid(mousePos.y),
              rotation: 0,
            };
            circuitElements.push(newTerminal);
            saveState();
            redrawCanvas();
            return;
          }

          // Priority 1: Handle switches (they have a special toggle action)
          if (clickedElement.type === "switch") {
            clickedElement.state =
              clickedElement.state === "closed" ? "open" : "closed";
            saveState();
            redrawCanvas();
            return;
          }
          if (clickedElement.type === "spdtSwitch") {
            clickedElement.state = clickedElement.state === 1 ? 2 : 1;
            saveState();
            redrawCanvas();
            return;
          }

          // Priority 2: Handle text labels (opens the editor modal)
          if (clickedElement.type === "text") {
            showTextInputModal(
              clickedElement.text,
              clickedElement.isItalic ?? true
            )
              .then(({ text, isItalic }) => {
                clickedElement.text = evaluateExpressions(text); // Also evaluate on edit
                clickedElement.isItalic = isItalic;
                saveState();
                redrawCanvas();
              })
              .catch(() => {
                /* User cancelled, do nothing */
              });
            return;
          }

          // --- START: NEW LOGIC FOR COMPONENT ROTATION ---
          // Priority 3: For any other component (not a wire, junction, etc.), prompt for rotation.
          const isRotatableComponent =
            clickedElement.type !== "wire" &&
            clickedElement.type !== "junction" &&
            clickedElement.type !== "open_terminal";

          if (isRotatableComponent) {
            const currentRotation = clickedElement.rotation || 0;
            const newRotationStr = prompt(
              "Enter new rotation angle (in degrees):",
              currentRotation
            );

            // If user clicks "Cancel", the prompt returns null.
            if (newRotationStr === null) {
              return;
            }

            const newRotation = parseFloat(newRotationStr);

            // Check if the input is a valid number
            if (isNaN(newRotation)) {
              alert("Invalid angle. Please enter a number.");
              return;
            }

            // Update the element's rotation and redraw
            clickedElement.rotation = newRotation;
            saveState();
            redrawCanvas();
            return; // We're done, so exit the function
          }
          // --- END: NEW LOGIC FOR COMPONENT ROTATION ---

          // If we reach here, it means a wire, junction, or existing terminal was double-clicked.
          // In this case, we do nothing.
        }

        canvas.addEventListener("mousedown", handleMouseDown);
        canvas.addEventListener("mousemove", handleMouseMove);
        canvas.addEventListener("mouseup", handleMouseUp);
        canvas.addEventListener("dblclick", handleDoubleClick);
        canvas.addEventListener("mouseout", () => {
          isDrawingWire = false;
          isDragging = false;
          isMarqueeSelecting = false;
          marqueeStartPoint = null;
          isShiftDown = false;
          hoveredWireSegment = null;
          redrawCanvas();
        });

        function getMousePos(e) {
          return {
            x: e.clientX - canvas.getBoundingClientRect().left,
            y: e.clientY - canvas.getBoundingClientRect().top,
          };
        }
        function snapToGrid(val) {
          return Math.round(val / (gridSize / 4)) * (gridSize / 4);
        }

        function getWireSegmentSnapPoint(pos) {
          for (const wire of circuitElements) {
            if (wire.type !== "wire") continue;
            const path = getWirePath(wire);
            for (let i = 0; i < path.length - 1; i++) {
              const p1 = path[i];
              const p2 = path[i + 1];
              if (distToSegment(pos, p1, p2) < snapTolerance) {
                // First, find the closest point on the line, just like before.
                const projectedPoint = projectPointOnSegment(pos, p1, p2);

                // NEW: Now, snap that projected point to our new fine grid.
                const snappedX =
                  Math.round(projectedPoint.x / fineGridSize) * fineGridSize;
                const snappedY =
                  Math.round(projectedPoint.y / fineGridSize) * fineGridSize;

                return { x: snappedX, y: snappedY };
              }
            }
          }
          return null;
        }

        function getSnappingPoint(x, y) {
          if (selectedTool === "wire") {
            const segmentSnap = getWireSegmentSnapPoint({ x, y });
            if (segmentSnap) return segmentSnap;
          }
          for (const el of circuitElements) {
            if (
              el.type === "wire" ||
              el.type === "text" ||
              el.type === "junction" ||
              el.type === "open_terminal"
            )
              continue;
            const terminals = getAbsoluteTerminals(el);
            for (const term of terminals) {
              if (Math.hypot(x - term.x, y - term.y) < snapTolerance)
                return { x: term.x, y: term.y, ownerId: el.id };
            }
          }
          for (const el of circuitElements) {
            if (el.type === "junction" || el.type === "open_terminal") {
              if (Math.hypot(x - el.x, y - el.y) < snapTolerance)
                return { x: el.x, y: el.y, ownerId: el.id };
            }
          }
          for (const el of circuitElements) {
            if (el.type !== "wire") continue;
            if (Math.hypot(x - el.start.x, y - el.start.y) < snapTolerance)
              return { x: el.start.x, y: el.start.y };
            if (Math.hypot(x - el.end.x, y - el.end.y) < snapTolerance)
              return { x: el.end.x, y: el.end.y };
          }
          return { x: snapToGrid(x), y: snapToGrid(y), ownerId: null };
        }

        function getAbsoluteTerminals(el) {
          const data = componentData[el.type];
          if (!data || !data.terminals) return [];
          const angle = (el.rotation * Math.PI) / 180,
            cos = Math.cos(angle),
            sin = Math.sin(angle);
          return data.terminals.map((t) => ({
            x: el.x + (t.x * cos - t.y * sin),
            y: el.y + (t.x * sin + t.y * cos),
          }));
        }
        function getElementAtPos(x, y) {
          for (let i = circuitElements.length - 1; i >= 0; i--) {
            const el = circuitElements[i];
            if (el.type === "junction" || el.type === "open_terminal") {
              if (Math.hypot(x - el.x, y - el.y) < snapTolerance) return el;
            }
          }
          for (let i = circuitElements.length - 1; i >= 0; i--) {
            const el = circuitElements[i];
            if (
              el.type === "wire" ||
              el.type === "junction" ||
              el.type === "open_terminal"
            )
              continue;
            if (el.type === "text") {
              const { width, height } = measureParsedText(el);
              const padding = 4;
              if (
                x > el.x - width / 2 - padding &&
                x < el.x + width / 2 + padding &&
                y > el.y - height / 2 - padding &&
                y < el.y + height / 2 + padding
              ) {
                return el;
              }
            } else {
              const data = componentData[el.type];
              const dx = x - el.x,
                dy = y - el.y,
                angle = (-el.rotation * Math.PI) / 180;
              const rX = dx * Math.cos(angle) - dy * Math.sin(angle),
                rY = dx * Math.sin(angle) + dy * Math.cos(angle);
              if (
                Math.abs(rX) < data.width / 2 &&
                Math.abs(rY) < data.height / 2
              )
                return el;
            }
          }
          for (let i = circuitElements.length - 1; i >= 0; i--) {
            const el = circuitElements[i];
            if (el.type !== "wire") continue;
            if (isPointOnWire({ x, y }, el)) return el;
          }
          return null;
        }
        function distToSegment(p, v, w) {
          const l2 = (v.x - w.x) ** 2 + (v.y - w.y) ** 2;
          if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
          let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
          t = Math.max(0, Math.min(1, t));
          return Math.hypot(
            p.x - (v.x + t * (w.x - v.x)),
            p.y - (v.y + t * (w.y - v.y))
          );
        }

        function projectPointOnSegment(p, v, w) {
          const l2 = (v.x - w.x) ** 2 + (v.y - w.y) ** 2;
          if (l2 === 0) return { x: v.x, y: v.y };
          let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
          t = Math.max(0, Math.min(1, t));
          return { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) };
        }

        function isPointOnWire(point, wire) {
          const path = getWirePath(wire);
          for (let i = 0; i < path.length - 1; i++) {
            if (distToSegment(point, path[i], path[i + 1]) < snapTolerance)
              return true;
          }
          return false;
        }
        function isElementInRect(el, rect) {
          if (el.type !== "wire") {
            return (
              el.x >= rect.x1 &&
              el.x <= rect.x2 &&
              el.y >= rect.y1 &&
              el.y <= rect.y2
            );
          }
          if (el.type === "wire") {
            const startIn =
              el.start.x >= rect.x1 &&
              el.start.x <= rect.x2 &&
              el.start.y >= rect.y1 &&
              el.start.y <= rect.y2;
            const endIn =
              el.end.x >= rect.x1 &&
              el.end.x <= rect.x2 &&
              el.end.y >= rect.y1 &&
              el.end.y <= rect.y2;
            return startIn && endIn;
          }
          return false;
        }

        function drawGrid() {
          ctx.strokeStyle = "#e9ecef";
          ctx.lineWidth = 1;
          ctx.beginPath();
          for (let x = 0; x <= canvas.width; x += gridSize) {
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
          }
          for (let y = 0; y <= canvas.height; y += gridSize) {
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
          }
          ctx.stroke();
        }
        function drawSelection() {
          if (selectedElements.length === 0) return;
          selectedElements.forEach((el) => {
            ctx.save();
            ctx.strokeStyle = "#007bff";
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 2]);
            if (el.type === "wire") {
              drawWire(el, true);
            } else if (el.type === "text") {
              const { width, height } = measureParsedText(el);
              const padding = 4;
              ctx.strokeRect(
                el.x - width / 2 - padding,
                el.y - height / 2 - padding,
                width + padding * 2,
                height + padding * 2
              );
            } else if (el.type === "junction" || el.type === "open_terminal") {
              ctx.translate(el.x, el.y);
              ctx.beginPath();
              ctx.arc(0, 0, 8, 0, 2 * Math.PI);
              ctx.stroke();
            } else {
              const data = componentData[el.type];
              ctx.translate(el.x, el.y);
              ctx.rotate((el.rotation * Math.PI) / 180);
              ctx.strokeRect(
                -data.width / 2,
                -data.height / 2,
                data.width,
                data.height
              );
            }
            ctx.restore();
          });
        }
        function drawMarquee(start, end) {
          ctx.save();
          ctx.fillStyle = "rgba(0, 123, 255, 0.1)";
          ctx.strokeStyle = "rgba(0, 123, 255, 0.5)";
          ctx.lineWidth = 1;
          ctx.setLineDash([6, 3]);
          const width = end.x - start.x,
            height = end.y - start.y;
          ctx.beginPath();
          ctx.rect(start.x, start.y, width, height);
          ctx.fill();
          ctx.stroke();
          ctx.restore();
        }
        function drawSnapIndicator(point) {
          ctx.beginPath();
          ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);
          ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
          ctx.fill();
        }
        function getWirePath(wire) {
          return wire.routing === "direct"
            ? [wire.start, wire.end]
            : [wire.start, { x: wire.start.x, y: wire.end.y }, wire.end];
        }
        function drawWireFromPath(path) {
          ctx.beginPath();
          ctx.moveTo(path[0].x, path[0].y);
          for (let i = 1; i < path.length; i++) {
            ctx.lineTo(path[i].x, path[i].y);
          }
          ctx.stroke();
        }
        function drawWire(el, isSelected) {
          setDrawingStyle(isSelected, el.color); // <-- MODIFY THIS LINE
          drawWireFromPath(getWirePath(el));
        }
        function drawWirePreview(start, end) {
          ctx.save();
          setDrawingStyle(true);
          ctx.setLineDash([4, 4]);
          drawWireFromPath(
            getWirePath({
              start,
              end,
              routing: isShiftDown ? "direct" : "manhattan",
            })
          );
          ctx.restore();
        }

        function drawJunctions() {
          const connectionPoints = new Map();
          const addPoint = (p) => {
            const key = `${p.x},${p.y}`;
            connectionPoints.set(key, (connectionPoints.get(key) || 0) + 1);
          };
          circuitElements.forEach((el) => {
            if (el.type === "wire") {
              addPoint(el.start);
              addPoint(el.end);
            } else if (el.type === "junction" || el.type === "open_terminal") {
              addPoint(el);
            } else if (el.type !== "text") {
              getAbsoluteTerminals(el).forEach((term) => addPoint(term));
            }
          });
          ctx.save();
          ctx.fillStyle = "#000";
          for (const [key, count] of connectionPoints.entries()) {
            if (count > 2) {
              const [x, y] = key.split(",").map(Number);
              ctx.beginPath();
              ctx.arc(x, y, 4, 0, 2 * Math.PI);
              ctx.fill();
            }
          }
          ctx.restore();
        }

        // ***************************************************************
        // START: NEW RECURSIVE TEXT PARSING, MEASURING, AND DRAWING ENGINE
        // ***************************************************************

        const greekSymbolMap = {
          alpha: "α",
          beta: "β",
          gamma: "γ",
          Delta: "Δ",
          delta: "δ",
          epsilon: "ε",
          eta: "η",
          theta: "θ",
          lambda: "λ",
          mu: "μ",
          pi: "π",
          rho: "ρ",
          Sigma: "Σ",
          sigma: "σ",
          tau: "τ",
          Phi: "Φ",
          phi: "φ",
          Omega: "Ω",
          omega: "ω",
          times: "×",
        };

        /**
         * Finds the index of the matching closing brace '}' for a given opening brace '{'.
         * Handles nested braces correctly.
         * @param {string} text - The full string to search within.
         * @param {number} startIndex - The index right after the opening brace.
         * @returns {number} - The index of the matching closing brace, or -1 if not found.
         */
        function findMatchingBrace(text, startIndex) {
          let braceLevel = 1;
          for (let i = startIndex; i < text.length; i++) {
            if (text[i] === "{") {
              braceLevel++;
            } else if (text[i] === "}") {
              braceLevel--;
              if (braceLevel === 0) {
                return i;
              }
            }
          }
          return -1; // Not found
        }

        /**
         * The main recursive parsing function.
         * @param {string} text - The segment of text to parse.
         * @returns {Array} - An array of parsed chunks.
         */
        function _parseInternal(text) {
          const chunks = [];
          let currentText = "";

          for (let i = 0; i < text.length; i++) {
            const char = text[i];
            let specialHandled = false;

            // Handle Subscript and Superscript
            if (char === "_" || char === "^") {
              if (currentText) {
                chunks.push({ type: "normal", text: currentText });
                currentText = "";
              }
              const type = char === "_" ? "subscript" : "superscript";
              let content = "";
              let jump = 0;

              if (text[i + 1] === "{") {
                const endBrace = findMatchingBrace(text, i + 2);
                if (endBrace !== -1) {
                  content = text.substring(i + 2, endBrace);
                  jump = endBrace - i;
                }
              } else if (i + 1 < text.length) {
                content = text[i + 1];
                jump = 1;
              }

              if (content) {
                chunks.push({ type: type, content: _parseInternal(content) });
                i += jump;
              } else {
                currentText += char; // Incomplete, treat as literal
              }
              specialHandled = true;
            }
            // Handle Commands like \frac or \mu
            else if (char === "\\") {
              if (currentText) {
                chunks.push({ type: "normal", text: currentText });
                currentText = "";
              }

              // Check for \frac{num}{den}
              if (
                text.substring(i, i + 5) === "\\frac" &&
                text[i + 5] === "{"
              ) {
                const numEnd = findMatchingBrace(text, i + 6);
                if (numEnd !== -1 && text[numEnd + 1] === "{") {
                  const denEnd = findMatchingBrace(text, numEnd + 2);
                  if (denEnd !== -1) {
                    const numerator = text.substring(i + 6, numEnd);
                    const denominator = text.substring(numEnd + 2, denEnd);
                    chunks.push({
                      type: "fraction",
                      numerator: _parseInternal(numerator),
                      denominator: _parseInternal(denominator),
                    });
                    i = denEnd;
                    specialHandled = true;
                  }
                }
              }
              // Check for Greek letters
              else {
                let symbolCandidate = "";
                let bestMatch = "";
                for (let j = i + 1; j < text.length; j++) {
                  if (!text[j].match(/[a-zA-Z]/)) break;
                  symbolCandidate += text[j];
                  if (greekSymbolMap.hasOwnProperty(symbolCandidate)) {
                    bestMatch = symbolCandidate;
                  }
                }
                if (bestMatch) {
                  chunks.push({
                    type: "normal",
                    text: greekSymbolMap[bestMatch],
                  });
                  i += bestMatch.length;
                  specialHandled = true;
                }
              }
            }

            if (!specialHandled) {
              currentText += char;
            }
          }
          if (currentText) chunks.push({ type: "normal", text: currentText });
          return chunks;
        }

        // Public entry point for parsing
        function parseText(rawText) {
          if (!rawText) return [];
          return _parseInternal(rawText);
        }

        /**
         * Recursively measures the dimensions of parsed text chunks.
         * @param {Array} chunks - The parsed chunks from parseText.
         * @param {number} currentFontSize - The font size for this level of recursion.
         * @param {boolean} isItalic - Whether to use italic font.
         * @returns {object} - An object with {width, height, ascent, descent}.
         */
        function measureRecursive(chunks, currentFontSize, isItalic) {
          let totalWidth = 0;
          let maxAscent = 0;
          let maxDescent = 0;
          const subSuperScale = 0.85;
          const fractionLinePadding = 4;
          const fontStyle = isItalic ? "italic" : "normal";

          ctx.font = `${fontStyle} ${currentFontSize}px Georgia`;
          const baselineHeight = ctx.measureText("M").width * 0.8;

          chunks.forEach((chunk) => {
            if (chunk.type === "normal") {
              ctx.font = `${fontStyle} ${currentFontSize}px Georgia`;
              const metrics = ctx.measureText(chunk.text);
              totalWidth += metrics.width;
              maxAscent = Math.max(maxAscent, baselineHeight);
              maxDescent = Math.max(maxDescent, 0);
            } else if (
              chunk.type === "subscript" ||
              chunk.type === "superscript"
            ) {
              const subMetrics = measureRecursive(
                chunk.content,
                currentFontSize * subSuperScale,
                isItalic
              );
              totalWidth += subMetrics.width;
              if (chunk.type === "superscript") {
                maxAscent = Math.max(
                  maxAscent,
                  subMetrics.height + baselineHeight * 0.4
                );
              } else {
                maxDescent = Math.max(
                  maxDescent,
                  subMetrics.height - baselineHeight * 0.4
                );
              }
            } else if (chunk.type === "fraction") {
              const numMetrics = measureRecursive(
                chunk.numerator,
                currentFontSize,
                isItalic
              );
              const denMetrics = measureRecursive(
                chunk.denominator,
                currentFontSize,
                isItalic
              );
              const fracWidth =
                Math.max(numMetrics.width, denMetrics.width) + 4;
              totalWidth += fracWidth;

              const fractionAscent = numMetrics.height + fractionLinePadding;
              const fractionDescent = denMetrics.height + fractionLinePadding;

              maxAscent = Math.max(maxAscent, fractionAscent);
              maxDescent = Math.max(maxDescent, fractionDescent);
            }
          });
          return {
            width: totalWidth,
            height: maxAscent + maxDescent,
            ascent: maxAscent,
            descent: maxDescent,
          };
        }

        function measureParsedText(el) {
          if (!el.text) return { width: 0, height: textFontSize };
          const isItalic = el.isItalic ?? true; // Backward compatibility
          const chunks = parseText(el.text);
          const metrics = measureRecursive(chunks, textFontSize, isItalic);
          return {
            width: metrics.width,
            height: Math.max(textFontSize, metrics.height),
          };
        }

        /**
         * Recursively draws parsed text chunks.
         * @param {Array} chunks - The parsed chunks to draw.
         * @param {number} x - The starting X coordinate.
         * @param {number} y - The baseline Y coordinate.
         * @param {number} currentFontSize - The font size for this level.
         * @param {boolean} isItalic - Whether to use italic font.
         * @returns {number} - The new X coordinate after drawing.
         */
        function drawRecursive(chunks, x, y, currentFontSize, isItalic) {
          let currentX = x;
          const subSuperScale = 0.85;
          const subSuperYOffsetFactor = 0.4;
          const fractionLinePadding = 4;
          const fontStyle = isItalic ? "italic" : "normal";

          ctx.font = `${fontStyle} ${currentFontSize}px Georgia`;

          chunks.forEach((chunk) => {
            if (chunk.type === "normal") {
              ctx.font = `${fontStyle} ${currentFontSize}px Georgia`;
              ctx.fillText(chunk.text, currentX, y);
              currentX += ctx.measureText(chunk.text).width;
            } else if (
              chunk.type === "subscript" ||
              chunk.type === "superscript"
            ) {
              const newFontSize = currentFontSize * subSuperScale;
              const yOffset =
                (chunk.type === "subscript" ? 1 : -1) *
                currentFontSize *
                subSuperYOffsetFactor;
              currentX = drawRecursive(
                chunk.content,
                currentX,
                y + yOffset,
                newFontSize,
                isItalic
              );
            } else if (chunk.type === "fraction") {
              const numMetrics = measureRecursive(
                chunk.numerator,
                currentFontSize,
                isItalic
              );
              const denMetrics = measureRecursive(
                chunk.denominator,
                currentFontSize,
                isItalic
              );
              const fracWidth = Math.max(numMetrics.width, denMetrics.width);

              const numX = currentX + (fracWidth - numMetrics.width) / 2;
              const denX = currentX + (fracWidth - denMetrics.width) / 2;

              const dividerY = y + 2;
              const numY = dividerY - numMetrics.descent - fractionLinePadding;
              const denY = dividerY + denMetrics.ascent + fractionLinePadding;

              drawRecursive(
                chunk.numerator,
                numX,
                numY,
                currentFontSize,
                isItalic
              );
              drawRecursive(
                chunk.denominator,
                denX,
                denY,
                currentFontSize,
                isItalic
              );

              ctx.beginPath();
              ctx.moveTo(currentX - 2, dividerY + 4);
              ctx.lineTo(currentX + fracWidth + 2, dividerY + 4);
              ctx.stroke();

              currentX += fracWidth + 4;
            }
          });
          return currentX;
        }

        function drawText(el, isSelected) {
          // New lines in drawText()
          const baseColor = el.color === "red" ? "red" : "black";
          ctx.fillStyle = isSelected ? "#007bff" : baseColor;
          ctx.strokeStyle = ctx.fillStyle; // For fraction line
          ctx.textBaseline = "middle";
          ctx.textAlign = "left";

          const isItalic = el.isItalic ?? true; // Backward compatibility
          const chunks = parseText(el.text);
          const {
            width: totalWidth,
            ascent,
            descent,
          } = measureRecursive(chunks, textFontSize, isItalic);
          const totalHeight = ascent + descent;

          // Center the entire block vertically
          const startY = el.y - totalHeight / 2 + ascent;
          const startX = el.x - totalWidth / 2;

          drawRecursive(chunks, startX, startY, textFontSize, isItalic);
        }

        // ***************************************************************
        // END: NEW RECURSIVE TEXT PARSING, MEASURING, AND DRAWING ENGINE
        // ***************************************************************

        function drawManualJunction() {
          ctx.beginPath();
          ctx.arc(0, 0, 4, 0, 2 * Math.PI);
          ctx.fillStyle = ctx.strokeStyle;
          ctx.fill();
        }
        function drawOpenTerminal() {
          ctx.beginPath();
          ctx.arc(0, 0, 4, 0, 2 * Math.PI);
          ctx.fillStyle = "#fff";
          ctx.fill();
          ctx.strokeStyle = "#000";
          ctx.stroke();
        }

        function drawResistor() {
          const w = 18,
            h = 9;
          ctx.beginPath();
          ctx.moveTo(-40, 0);
          ctx.lineTo(-w, 0);
          ctx.moveTo(-w, 0);
          for (let i = 0; i < 6; i++) {
            ctx.lineTo(-w + (i * 2 + 1) * (w / 6), i % 2 === 0 ? -h : h);
          }
          ctx.lineTo(w, 0);
          ctx.lineTo(40, 0);
          ctx.stroke();
        }
        function drawCapacitor() {
          const plateDist = 10,
            plateLen = 28;
          ctx.beginPath();
          ctx.moveTo(-40, 0);
          ctx.lineTo(-plateDist / 2, 0);
          ctx.moveTo(-plateDist / 2, -plateLen / 2);
          ctx.lineTo(-plateDist / 2, plateLen / 2);
          ctx.moveTo(plateDist / 2, -plateLen / 2);
          ctx.lineTo(plateDist / 2, plateLen / 2);
          ctx.moveTo(plateDist / 2, 0);
          ctx.lineTo(40, 0);
          ctx.stroke();
        }
        function drawInductor() {
          // 1. READ the desired final line width from the context.
          //    This will be '2' after setDrawingStyle(false) is called.
          const baseLineWidth = ctx.lineWidth;

          const originalCenterX = 218;
          const originalCenterY = 457;
          const originalWidth = 37.78;
          const targetWidth = 42;
          const scaleFactor = targetWidth / originalWidth;
          const angle = (-45 * Math.PI) / 180;

          // --- Draw the Transformed Inductor Coils ---
          ctx.save();

          // 2. COMPENSATE the line width for the upcoming scaling.
          //    This ensures the coils are drawn with a final visual thickness of 'baseLineWidth'.
          ctx.lineWidth = baseLineWidth / scaleFactor;

          // Apply transformations for the coils
          ctx.rotate(angle);
          ctx.scale(scaleFactor, scaleFactor);
          ctx.translate(-originalCenterX, -originalCenterY);

          // Define and draw the coil paths
          const pathData = [
            "m 219.95536,449.39345 c -1.70702,-1.35573 -4.87183,-1.13729 -7.47037,0.0774 -2.93691,1.3729 -6.23449,5.09529 -5.27517,6.50738",
            "m 219.95536,449.39345 c 1.35573,1.70702 1.13729,4.87183 -0.0774,7.47037 -1.3729,2.93691 -5.09529,6.23449 -6.50738,5.27517",
            "m 213.7946,443.23269 c 1.35573,1.70702 1.13729,4.87183 -0.0774,7.47037 -1.3729,2.93691 -5.09529,6.23449 -6.50738,5.27517",
            "m 226.11612,455.55421 c -1.70702,-1.35573 -4.87183,-1.13729 -7.47037,0.0774 -2.93691,1.3729 -6.23449,5.09529 -5.27517,6.50738",
            "m 226.11612,455.55421 c 1.35573,1.70702 1.13729,4.87183 -0.0774,7.47037 -1.3729,2.93691 -5.09529,6.23449 -6.50738,5.27517",
            "m 232.27688,461.71497 c -1.70702,-1.35573 -4.87183,-1.13729 -7.47037,0.0774 -2.93691,1.3729 -6.23449,5.09529 -5.27517,6.50738",
            "m 232.27688,461.71497 c 1.63452,1.48399 0.9202,6.50391 -1.11912,9.36441",
            "m 213.7946,443.23269 c -1.48399,-1.63452 -6.50391,-0.9202 -9.36441,1.11912",
          ];
          const paths = pathData.map((d) => new Path2D(d));
          paths.forEach((path) => ctx.stroke(path));
          ctx.restore();

          // --- Draw the Connecting Lines ---
          // These lines are not scaled, so we can use the baseLineWidth directly.
          ctx.beginPath();
          ctx.moveTo(-40, 0);
          ctx.lineTo(-21, 0);
          ctx.moveTo(21, 0);
          ctx.lineTo(40, 0);
          // The line width is already set to 2 by setDrawingStyle, so we just stroke.
          ctx.stroke();
        }

        function drawSwitch(el) {
          const circleRadius = 4,
            leftContactX = -15,
            rightContactX = 15;
          ctx.beginPath();
          ctx.moveTo(-40, 0);
          ctx.lineTo(leftContactX, 0);
          ctx.moveTo(40, 0);
          ctx.lineTo(rightContactX, 0);
          if (el.state === "closed") {
            ctx.moveTo(leftContactX, -5);
            ctx.lineTo(rightContactX, -5);
          } else {
            const bladeLength = 30,
              bladeAngle = (-30 * Math.PI) / 180;
            ctx.moveTo(leftContactX, 0);
            ctx.lineTo(
              leftContactX + bladeLength * Math.cos(bladeAngle),
              bladeLength * Math.sin(bladeAngle)
            );
          }
          ctx.stroke();
          ctx.save();
          ctx.fillStyle = "white";
          ctx.beginPath();
          ctx.arc(leftContactX, 0, circleRadius, 0, 2 * Math.PI);
          ctx.fill();
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(rightContactX, 0, circleRadius, 0, 2 * Math.PI);
          ctx.fill();
          ctx.stroke();
          ctx.restore();
        }
        function drawSpdtSwitch(el) {
          const circleRadius = 4,
            commonX = -15,
            throwX = 15,
            throwY1 = -20,
            throwY2 = 20;

          // Draw lead wires to external terminals
          ctx.beginPath();
          ctx.moveTo(-40, 0);
          ctx.lineTo(commonX, 0);
          ctx.moveTo(throwX, throwY1);
          ctx.lineTo(40, throwY1);
          ctx.moveTo(throwX, throwY2);
          ctx.lineTo(40, throwY2);

          // Draw switch blade
          if (el.state === 2) {
            ctx.moveTo(commonX, 0);
            ctx.lineTo(throwX, throwY2);
          } else {
            // state 1 is default
            ctx.moveTo(commonX, 0);
            ctx.lineTo(throwX, throwY1);
          }
          ctx.stroke();

          // Draw contact circles
          ctx.save();
          ctx.fillStyle = "white";
          [
            { x: commonX, y: 0 },
            { x: throwX, y: throwY1 },
            { x: throwX, y: throwY2 },
          ].forEach((p) => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, circleRadius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
          });
          ctx.restore();
        }
        function drawArrowhead(ctx, fromX, fromY, toX, toY, headLength = 12) {
          const angle = Math.atan2(toY - fromY, toX - fromX);
          const arrowAngle = Math.PI / 7;

          // Start a new path for the arrowhead so it can be filled separately
          ctx.beginPath();

          // Move to the tip of the arrow
          ctx.moveTo(toX, toY);

          // Draw a line to the first corner of the arrowhead base
          ctx.lineTo(
            toX - headLength * Math.cos(angle - arrowAngle),
            toY - headLength * Math.sin(angle - arrowAngle)
          );

          // Draw a line to the second corner of the arrowhead base
          ctx.lineTo(
            toX - headLength * Math.cos(angle + arrowAngle),
            toY - headLength * Math.sin(angle + arrowAngle)
          );

          // Close the path to complete the triangle
          ctx.closePath();

          // Fill the closed path
          ctx.fill();
        }

        // --- IGBT Drawing Function ---
        // The drawing is split into two parts: stroking the lines and filling the arrowhead.
        function drawIGBT() {
          // --- Part 1: Draw and stroke the main lines of the symbol ---
          ctx.beginPath();

          // Gate
          ctx.moveTo(10 - 40, 65 - 55);
          ctx.lineTo(38 - 40, 65 - 55); // Gate lead
          ctx.moveTo(38 - 40, 65 - 55);
          ctx.lineTo(38 - 40, 43 - 55); // Gate plate

          // Channel (Capacitor Plate)
          ctx.moveTo(45 - 40, 75 - 55);
          ctx.lineTo(45 - 40, 35 - 55);

          // Collector & Emitter leads
          ctx.moveTo(70 - 40, 35 - 55);
          ctx.lineTo(70 - 40, 5 - 55); // Collector lead
          ctx.moveTo(70 - 40, 75 - 55);
          ctx.lineTo(70 - 40, 105 - 55); // Emitter lead

          // Slanted connections
          ctx.moveTo(70 - 40, 35 - 55);
          ctx.lineTo(45 - 40, 48 - 55); // Top slant

          // Define start and end points for the bottom slant
          const fromX = 45 - 40,
            fromY = 62 - 55;
          const toX = 70 - 40,
            toY = 75 - 55;

          // Draw the bottom slant line itself
          ctx.moveTo(fromX, fromY);
          ctx.lineTo(toX, toY);

          // Render all the lines defined above
          ctx.stroke();

          // --- Part 2: Draw the filled arrowhead ---
          // This is done as a separate operation to allow it to be a filled shape.
          drawArrowhead(ctx, fromX, fromY, toX, toY);
        }

        function drawNFET() {
          // --- Part 1: Draw and stroke the main lines of the symbol ---
          ctx.beginPath();

          // Gate
          ctx.moveTo(10 - 40, 75 - 55);
          ctx.lineTo(38 - 40, 75 - 55); // Gate lead
          ctx.moveTo(38 - 40, 75 - 55);
          ctx.lineTo(38 - 40, 35 - 55); // Gate plate

          // Channel (Drain Plate)
          ctx.moveTo(45 - 40, 35 - 55);
          ctx.lineTo(45 - 40, 43 - 55);
          ctx.moveTo(45 - 40, 39 - 55);
          ctx.lineTo(70 - 40, 39 - 55);
          // Channel (Gate Plate)
          ctx.moveTo(45 - 40, 51 - 55);
          ctx.lineTo(45 - 40, 59 - 55);
          ctx.moveTo(45 - 40, 55 - 55);
          ctx.lineTo(70 - 40, 55 - 55);

          // Channel (Source Plate)
          ctx.moveTo(45 - 40, 67 - 55);
          ctx.lineTo(45 - 40, 75 - 55);
          ctx.moveTo(45 - 40, 71 - 55);
          ctx.lineTo(70 - 40, 71 - 55);

          // Collector & Emitter leads
          ctx.moveTo(70 - 40, 39 - 55);
          ctx.lineTo(70 - 40, 5 - 55); // Drain lead
          ctx.moveTo(70 - 40, 55 - 55);
          ctx.lineTo(70 - 40, 105 - 55); // Source lead

          // Render all the lines defined above
          ctx.stroke();

          // --- Part 2: Draw the filled arrowhead ---
          // This is done as a separate operation to allow it to be a filled shape.
          drawArrowhead(ctx, 70 - 40, 55 - 55, 45 - 40, 55 - 55);
        }

        function drawPFET() {
          // --- Part 1: Draw and stroke the main lines of the symbol ---
          ctx.beginPath();

          // Gate
          ctx.moveTo(10 - 40, 75 - 55);
          ctx.lineTo(38 - 40, 75 - 55); // Gate lead
          ctx.moveTo(38 - 40, 75 - 55);
          ctx.lineTo(38 - 40, 35 - 55); // Gate plate

          // Channel (Drain Plate)
          ctx.moveTo(45 - 40, 35 - 55);
          ctx.lineTo(45 - 40, 43 - 55);
          ctx.moveTo(45 - 40, 39 - 55);
          ctx.lineTo(70 - 40, 39 - 55);
          // Channel (Gate Plate)
          ctx.moveTo(45 - 40, 51 - 55);
          ctx.lineTo(45 - 40, 59 - 55);
          ctx.moveTo(45 - 40, 55 - 55);
          ctx.lineTo(70 - 40, 55 - 55);

          // Channel (Source Plate)
          ctx.moveTo(45 - 40, 67 - 55);
          ctx.lineTo(45 - 40, 75 - 55);
          ctx.moveTo(45 - 40, 71 - 55);
          ctx.lineTo(70 - 40, 71 - 55);

          // Collector & Emitter leads
          ctx.moveTo(70 - 40, 39 - 55);
          ctx.lineTo(70 - 40, 5 - 55); // Drain lead
          ctx.moveTo(70 - 40, 55 - 55);
          ctx.lineTo(70 - 40, 105 - 55); // Source lead

          // Render all the lines defined above
          ctx.stroke();

          // --- Part 2: Draw the filled arrowhead ---
          // This is done as a separate operation to allow it to be a filled shape.
          drawArrowhead(ctx, 45 - 40, 55 - 55, 70 - 40, 55 - 55);
        }
        function drawNPN() {
          // --- Part 1: Draw and stroke the main lines of the symbol ---
          ctx.beginPath();

          // Base
          ctx.moveTo(10 - 40, 55 - 55);
          ctx.lineTo(42 - 40, 55 - 55); // Base lead
          ctx.moveTo(42 - 40, 75 - 55);
          ctx.lineTo(42 - 40, 35 - 55); // Base plate

          // Collector & Emitter leads
          ctx.moveTo(70 - 40, 35 - 55);
          ctx.lineTo(70 - 40, 5 - 55); // Collector lead
          ctx.moveTo(70 - 40, 75 - 55);
          ctx.lineTo(70 - 40, 105 - 55); // Emitter lead

          // Slanted connections
          ctx.moveTo(70 - 40, 35 - 55);
          ctx.lineTo(42 - 40, 48 - 55); // Top slant

          // Define start and end points for the bottom slant
          const fromX = 42 - 40,
            fromY = 62 - 55;
          const toX = 70 - 40,
            toY = 75 - 55;

          // Draw the bottom slant line itself
          ctx.moveTo(fromX, fromY);
          ctx.lineTo(toX, toY);

          // Render all the lines defined above
          ctx.stroke();

          // --- Part 2: Draw the filled arrowhead ---
          // This is done as a separate operation to allow it to be a filled shape.
          drawArrowhead(ctx, fromX, fromY, toX, toY);
        }

        function drawPNP() {
          // --- Part 1: Draw and stroke the main lines of the symbol ---
          ctx.beginPath();

          // Base
          ctx.moveTo(10 - 40, 55 - 55);
          ctx.lineTo(42 - 40, 55 - 55); // Base lead
          ctx.moveTo(42 - 40, 75 - 55);
          ctx.lineTo(42 - 40, 35 - 55); // Base plate

          // Collector & Emitter leads
          ctx.moveTo(70 - 40, 35 - 55);
          ctx.lineTo(70 - 40, 5 - 55); // Collector lead
          ctx.moveTo(70 - 40, 75 - 55);
          ctx.lineTo(70 - 40, 105 - 55); // Emitter lead

          // Slanted connections
          ctx.moveTo(70 - 40, 35 - 55);
          ctx.lineTo(42 - 40, 48 - 55); // Top slant

          // Define start and end points for the bottom slant
          const fromX = 70 - 40,
            fromY = 75 - 55;
          const toX = 42 - 40,
            toY = 62 - 55;

          // Draw the bottom slant line itself
          ctx.moveTo(fromX, fromY);
          ctx.lineTo(toX, toY);

          // Render all the lines defined above
          ctx.stroke();

          // --- Part 2: Draw the filled arrowhead ---
          // This is done as a separate operation to allow it to be a filled shape.
          drawArrowhead(ctx, 70 - 40, 35 - 55, 42 - 40, 48 - 55);
        }

        function drawDiode() {
          const triHeight = 22,
            baseX = -10,
            tipX = 10;
          ctx.beginPath();
          ctx.lineJoin = "round";
          ctx.moveTo(-30, 0);
          ctx.lineTo(baseX, 0);
          ctx.moveTo(tipX, 0);
          ctx.lineTo(30, 0);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(baseX, -triHeight / 2);
          ctx.lineTo(tipX, 0);
          ctx.lineTo(baseX, triHeight / 2);
          ctx.closePath();
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(tipX, -triHeight / 2);
          ctx.lineTo(tipX, triHeight / 2);
          ctx.stroke();
        }

        function drawFWD() {
          const triHeight = 12,
            baseX = -6,
            tipX = 6;
          ctx.beginPath();
          ctx.lineJoin = "round";
          ctx.moveTo(-30, 0);
          ctx.lineTo(baseX, 0);
          ctx.moveTo(tipX, 0);
          ctx.lineTo(30, 0);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(baseX, -triHeight / 2);
          ctx.lineTo(tipX, 0);
          ctx.lineTo(baseX, triHeight / 2);
          ctx.closePath();
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(tipX, -triHeight / 2);
          ctx.lineTo(tipX, triHeight / 2);
          ctx.stroke();
        }

        function drawZenerDiode() {
          drawDiode();
          const tipX = 10,
            h = 11,
            tick = 5;
          ctx.beginPath();
          ctx.moveTo(tipX, -h);
          ctx.lineTo(tipX - tick, -h - tick);
          ctx.moveTo(tipX, h);
          ctx.lineTo(tipX + tick, h + tick);
          ctx.stroke();
        }
        function drawLED() {
          drawDiode();
          ctx.save();
          ctx.lineCap = "round";
          ctx.lineWidth = ctx.lineWidth * 0.6;
          ctx.beginPath();
          ctx.moveTo(-3, -12);
          ctx.lineTo(8, -24);
          ctx.moveTo(4, -22);
          ctx.lineTo(8, -24);
          ctx.lineTo(6, -20);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(2, -9);
          ctx.lineTo(13, -21);
          ctx.moveTo(9, -19);
          ctx.lineTo(13, -21);
          ctx.lineTo(11, -17);
          ctx.stroke();
          ctx.restore();
        }
        function drawVoltageSource() {
          const r = 16;
          ctx.beginPath();
          ctx.arc(0, 0, r, 0, 2 * Math.PI);
          ctx.moveTo(0, -30);
          ctx.lineTo(0, -r);
          ctx.moveTo(0, r);
          ctx.lineTo(0, 30);
          ctx.moveTo(-r / 4, -r / 2);
          ctx.lineTo(r / 4, -r / 2);
          ctx.moveTo(0, -r / 2 - 5);
          ctx.lineTo(0, -r / 2 + 5);
          ctx.moveTo(-r / 4, r / 2);
          ctx.lineTo(r / 4, r / 2);
          ctx.stroke();
        }
        function drawACVoltageSource() {
          const r = 16;
          ctx.beginPath();
          ctx.arc(0, 0, r, 0, 2 * Math.PI);
          ctx.moveTo(0, -30);
          ctx.lineTo(0, -r);
          ctx.moveTo(0, r);
          ctx.lineTo(0, 30);
          const waveStartX = -10,
            waveEndX = 10,
            waveAmplitude = 8;
          ctx.moveTo(waveStartX, 0);
          ctx.quadraticCurveTo(waveStartX / 2, -waveAmplitude, 0, 0);
          ctx.quadraticCurveTo(waveEndX / 2, waveAmplitude, waveEndX, 0);
          ctx.stroke();
        }
        function drawCurrentSource() {
          const r = 16,
            arrowY_start = -10,
            arrowY_end = 10,
            arrowHeadSize = 6;
          ctx.beginPath();
          ctx.arc(0, 0, r, 0, 2 * Math.PI);
          ctx.moveTo(0, -30);
          ctx.lineTo(0, -r);
          ctx.moveTo(0, r);
          ctx.lineTo(0, 30);
          ctx.moveTo(-arrowHeadSize / 2, arrowY_start + arrowHeadSize);
          ctx.lineTo(0, arrowY_start);
          ctx.lineTo(arrowHeadSize / 2, arrowY_start + arrowHeadSize);
          ctx.moveTo(0, arrowY_end);
          ctx.lineTo(0, 0);
          ctx.lineTo(0, -5);
          ctx.stroke();
        }
        function drawDependentVoltageSource() {
          const w = 20,
            h = 20; // half-width and half-height of the diamond
          ctx.beginPath();
          // Draw leads
          ctx.moveTo(0, -30);
          ctx.lineTo(0, -h);
          ctx.moveTo(0, h);
          ctx.lineTo(0, 30);
          // Draw diamond
          ctx.moveTo(0, -h);
          ctx.lineTo(w, 0);
          ctx.lineTo(0, h);
          ctx.lineTo(-w, 0);
          ctx.closePath();
          // Draw '+' and '-' signs
          const signSize = 4;
          // Plus sign at top
          ctx.moveTo(-signSize, -h * 0.5 + 2);
          ctx.lineTo(signSize, -h * 0.5 + 2);
          ctx.moveTo(0, -h * 0.5 - signSize + 2);
          ctx.lineTo(0, -h * 0.5 + signSize + 2);
          // Minus sign at bottom
          ctx.moveTo(-signSize, h * 0.5 - 2);
          ctx.lineTo(signSize, h * 0.5 - 2);
          ctx.stroke();
        }
        function drawDependentCurrentSource() {
          const w = 20,
            h = 20; // half-width and half-height of the diamond
          ctx.beginPath();
          // Draw leads
          ctx.moveTo(0, -30);
          ctx.lineTo(0, -h);
          ctx.moveTo(0, h);
          ctx.lineTo(0, 30);
          // Draw diamond
          ctx.moveTo(0, -h);
          ctx.lineTo(w, 0);
          ctx.lineTo(0, h);
          ctx.lineTo(-w, 0);
          ctx.closePath();
          // Draw arrow inside (pointing up)
          const arrowY_start = -h * 0.7,
            arrowY_end = h * 0.7,
            arrowHeadSize = 6;
          ctx.moveTo(0, arrowY_end); // Start from bottom of arrow shaft
          ctx.lineTo(0, arrowY_start); // Draw up to top
          // Arrow head
          ctx.moveTo(-arrowHeadSize / 2, arrowY_start + arrowHeadSize);
          ctx.lineTo(0, arrowY_start);
          ctx.lineTo(arrowHeadSize / 2, arrowY_start + arrowHeadSize);
          ctx.stroke();
        }
        function drawBattery() {
          const longPlateW = 34,
            shortPlateW = 14,
            plateY1 = -5,
            plateY2 = 5;
          const plusSignX = 10,
            plusSignY = -16,
            plusSignSize = 4;
          ctx.beginPath();
          ctx.moveTo(0, -30);
          ctx.lineTo(0, plateY1);
          ctx.moveTo(0, plateY2);
          ctx.lineTo(0, 30);
          ctx.moveTo(-longPlateW / 2, plateY1);
          ctx.lineTo(longPlateW / 2, plateY1);
          ctx.moveTo(plusSignX - plusSignSize, plusSignY);
          ctx.lineTo(plusSignX + plusSignSize, plusSignY);
          ctx.moveTo(plusSignX, plusSignY - plusSignSize);
          ctx.lineTo(plusSignX, plusSignY + plusSignSize);
          ctx.stroke();
          ctx.save();
          ctx.lineWidth = ctx.lineWidth * 2;
          ctx.beginPath();
          ctx.moveTo(-shortPlateW / 2, plateY2);
          ctx.lineTo(shortPlateW / 2, plateY2);
          ctx.stroke();
          ctx.restore();
        }
        function drawGround() {
          ctx.beginPath();
          ctx.moveTo(0, -10);
          ctx.lineTo(0, 0);
          ctx.moveTo(-15, 0);
          ctx.lineTo(15, 0);
          ctx.moveTo(-10, 6);
          ctx.lineTo(10, 6);
          ctx.moveTo(-5, 12);
          ctx.lineTo(5, 12);
          ctx.stroke();
        }
        function drawArrowMarker(el) {
          ctx.fillStyle = el.color || "black";
          ctx.beginPath();
          // A small arrow head. Let's say 12px long, 8px wide.
          // Tip points along the positive x-axis.
          const length = 16;
          const width = 10;
          ctx.moveTo(length / 2, 0); // Tip
          ctx.lineTo(-length / 2, -width / 2);
          ctx.lineTo(-length / 2, width / 2);
          ctx.closePath();
          ctx.fill();
        }
        function calculateBoundingBox() {
          if (circuitElements.length === 0) return null;
          let minX = Infinity,
            minY = Infinity,
            maxX = -Infinity,
            maxY = -Infinity;
          circuitElements.forEach((el) => {
            if (el.type === "wire") {
              const path = getWirePath(el);
              path.forEach((p) => {
                minX = Math.min(minX, p.x);
                maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y);
                maxY = Math.max(maxY, p.y);
              });
            } else if (el.type === "text") {
              const { width, height } = measureParsedText(el);
              minX = Math.min(minX, el.x - width / 2);
              maxX = Math.max(maxX, el.x + width / 2);
              minY = Math.min(minY, el.y - height / 2);
              maxY = Math.max(maxY, el.y + height / 2);
            } else if (el.type === "junction" || el.type === "open_terminal") {
              minX = Math.min(minX, el.x);
              maxX = Math.max(maxX, el.x);
              minY = Math.min(minY, el.y);
              maxY = Math.max(maxY, el.y);
            } else {
              const data = componentData[el.type];
              const w = data.width,
                h = data.height;
              const angle = (el.rotation * Math.PI) / 180;
              const cos = Math.cos(angle),
                sin = Math.sin(angle);
              const corners = [
                { x: -w / 2, y: -h / 2 },
                { x: w / 2, y: -h / 2 },
                { x: w / 2, y: h / 2 },
                { x: -w / 2, y: h / 2 },
              ];
              corners.forEach((c) => {
                const rx = el.x + c.x * cos - c.y * sin;
                const ry = el.y + c.x * sin + c.y * cos;
                minX = Math.min(minX, rx);
                maxX = Math.max(maxX, rx);
                minY = Math.min(minY, ry);
                maxY = Math.max(maxY, ry);
              });
            }
          });
          return { minX, minY, maxX, maxY };
        }

        /**
         * Universal function to parse a circuit JSON string and append it to the canvas.
         * @param {string} jsonString - The string containing the circuit data.
         * @param {string} successMessage - The message to show in the alert on success.
         * @returns {boolean} - True if appending was successful, false otherwise.
         */
        function appendCircuitFromJSON(
          jsonString,
          successMessage = "Circuit appended successfully!"
        ) {
          try {
            const data = JSON.parse(jsonString);
            if (data && data.elements && data.nextId !== undefined) {
              const currentBounds = calculateBoundingBox();
              const yOffset = currentBounds ? currentBounds.maxY + 100 : 0;

              const elementsToAppend = [];
              data.elements.forEach((el) => {
                const newEl = JSON.parse(JSON.stringify(el));
                newEl.id = nextId++;
                if (newEl.type === "wire") {
                  newEl.start.y += yOffset;
                  newEl.end.y += yOffset;
                } else {
                  if (newEl.y !== undefined) newEl.y += yOffset;
                }
                elementsToAppend.push(newEl);
              });

              if (elementsToAppend.length > 0) {
                circuitElements.push(...elementsToAppend);
              }

              const finalBounds = calculateBoundingBox();
              if (finalBounds) {
                resizeCanvas(finalBounds.maxX + 50, finalBounds.maxY + 50);
              }

              saveState();
              redrawCanvas();
              alert(successMessage);
              return true;
            } else {
              alert(
                "Operation failed: Invalid circuit data structure in the JSON."
              );
              return false;
            }
          } catch (e) {
            console.error("Could not parse input as circuit JSON.", e);
            alert(
              "Operation failed: Could not parse JSON. See console for details."
            );
            return false;
          }
        }

        /**
         * Prompts user for description, calls Gemini API, and appends the resulting circuit.
         */
        async function handleAIGenerate() {
          const description = prompt(
            "Describe the circuit you want to generate:",
            "A 9V battery in series with a 470 ohm resistor and a red LED, connected to ground."
          );
          if (!description) return;

          // --- ⚠️ IMPORTANT SECURITY WARNING ⚠️ ---
          // In a real-world application, NEVER expose your API key on the client-side like this.
          // An attacker could steal your key and use your account.
          // This key should be stored in a secure backend server that makes the API call.
          // For this demonstration, replace the placeholder with your key.
          const API_KEY = "AIzaSyCK5Pp_H-brLUOOQhA-0iDS2Z_yALEVvs0";

          if (API_KEY === "YOUR_GEMINI_API_KEY") {
            alert(
              "ERROR: Please open the HTML file, find the 'handleAIGenerate' function in the script, and replace 'YOUR_GEMINI_API_KEY' with your actual Gemini API key."
            );
            return;
          }

          const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${API_KEY}`;

          document.body.style.cursor = "wait";
          alert(
            "Generating circuit with AI... Please wait. This may take a moment."
          );

          const system_prompt = `You are a circuit design assistant for 'Circuit Drafter'. Your ONLY task is to generate a valid JSON object representing a circuit from a user's description. Your output MUST be a single, raw JSON object and nothing else. Do not include explanations or markdown formatting.

The JSON structure must be:
{
  "version": "0.4a",
  "elements": [ ... element objects ... ],
  "nextId": <number>
}

Valid element types and properties:
1. Component: {"id":<int>, "type":<string>, "x":<int>, "y":<int>, "rotation":<int>}
   - types: "resistor", "capacitor", "inductor", "diode", "zener", "led", "switch", "spdtSwitch", "voltage", "acvoltage", "currentsource", "battery", "gnd"
2. Wire: {"id":<int>, "type":"wire", "start":{"x":<int>,"y":<int>}, "end":{"x":<int>,"y":<int>}, "routing":"manhattan"}
3. Text Label: {"id":<int>, "type":"text", "text":<string>, "x":<int>, "y":<int>, "rotation":0, "isItalic":true}

RULES:
- Every element needs a unique integer 'id', starting from 0.
- 'nextId' must be one greater than the highest 'id'.
- Wires must connect to component terminals. A standard horizontal resistor at (x,y) has terminals at (x-40, y) and (x+40, y). A standard vertical voltage source has terminals at (x, y-30) and (x, y+30). Adhere to these dimensions.
- Create clean, logical layouts within a 1000x700 canvas area.
- Add labels for component names (e.g., "R_{1}") and values (e.g., "10k\\\\Omega", "5V"). Use LaTeX for subscripts and symbols.

Example Output for "A 5V DC source, a 1k resistor, and ground":
{
  "version": "0.40a",
  "elements": [
    { "id": 0, "type": "voltage", "x": 200, "y": 150, "rotation": 0 },
    { "id": 1, "type": "resistor", "x": 200, "y": 250, "rotation": 0 },
    { "id": 2, "type": "gnd", "x": 200, "y": 350, "rotation": 0 },
    { "id": 3, "type": "wire", "start": { "x": 200, "y": 120 }, "end": { "x": 200, "y": 210 }, "routing": "manhattan" },
    { "id": 4, "type": "wire", "start": { "x": 200, "y": 290 }, "end": { "x": 200, "y": 340 }, "routing": "manhattan" },
    { "id": 5, "type": "text", "text": "V_{in}", "x": 150, "y": 150, "rotation": 0, "isItalic": true },
    { "id": 6, "type": "text", "text": "5V", "x": 250, "y": 150, "rotation": 0, "isItalic": true },
    { "id": 7, "type": "text", "text": "R_{1}", "x": 150, "y": 250, "rotation": 0, "isItalic": true },
    { "id": 8, "type": "text", "text": "1k\\\\Omega", "x": 250, "y": 250, "rotation": 0, "isItalic": true }
  ],
  "nextId": 9
}`;

          try {
            const response = await nfetch(API_URL, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                contents: [
                  {
                    parts: [
                      { text: system_prompt },
                      { text: `\n\n**User Request**: "${description}"` },
                    ],
                  },
                ],
              }),
            });

            if (!response.ok) {
              const errorBody = await response.json();
              throw new Error(
                `API Error: ${response.status}. ${errorBody.error.message}`
              );
            }

            const responseData = await response.json();
            const jsonString = responseData.candidates[0].content.parts[0].text;
            const cleanedJsonString = jsonString.replace(
              /^```json\s*|```\s*$/g,
              ""
            );

            appendCircuitFromJSON(
              cleanedJsonString,
              "Circuit generated by AI and appended successfully!"
            );
          } catch (error) {
            console.error("AI Generation Error:", error);
            alert(
              `An error occurred while generating the circuit: ${error.message}`
            );
          } finally {
            document.body.style.cursor = "default";
          }
        }

        geminiAIBtn.addEventListener("click", handleAIGenerate);

        function handleSaveExport() {
          const choiceRaw = prompt(
            "Save as project file (json) or export as image (png)?",
            "json"
          );
          if (!choiceRaw) return;
          const choice = choiceRaw.toLowerCase().trim();

          if (choice === "json" || choice === "j") {
            saveCircuit();
          } else if (choice === "png" || choice === "p") {
            exportCircuit();
          } else {
            alert("Invalid choice. Please enter 'json' or 'png'.");
          }
        }

        function saveCircuit() {
          const filename = prompt(
            "Enter filename for project file:",
            "circuit.json"
          );
          if (!filename) return;
          const dataToSave = {
            version: "0.40a",
            elements: circuitElements,
            nextId: nextId,
          };
          const dataStr = JSON.stringify(dataToSave, null, 2);
          const blob = new Blob([dataStr], { type: "application/json" });
          const link = document.createElement("a");
          link.download = filename.endsWith(".json")
            ? filename
            : filename + ".json";
          link.href = URL.createObjectURL(blob);
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(link.href);
        }

        function handleFileLoad(event) {
          const file = event.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const data = JSON.parse(e.target.result);
              if (data && data.elements && data.nextId !== undefined) {
                // Load the new elements from the file
                circuitElements = data.elements;
                nextId = data.nextId;

                // --- START: New auto-resize logic for loaded files ---
                const bounds = calculateBoundingBox();
                if (bounds) {
                  const padding = 50; // Add some visual space around the loaded circuit
                  const requiredWidth = bounds.maxX + padding;
                  const requiredHeight = bounds.maxY + padding;
                  resizeCanvas(requiredWidth, requiredHeight);
                }
                // --- END: New auto-resize logic for loaded files ---

                // Reset the application state for the newly loaded circuit
                history = [];
                historyIndex = -1;
                selectedElements = [];
                recalculateAutoLabelCounters(); // Recalculate counters based on loaded text elements
                saveState();
                redrawCanvas();
                alert("Circuit loaded successfully!");
              } else {
                alert("Invalid or corrupted circuit file.");
              }
            } catch (error) {
              console.error("Error parsing JSON file:", error);
              alert(
                "Error reading file. Make sure it is a valid JSON circuit file."
              );
            }
            fileInput.value = ""; // Clear the input to allow reloading the same file
          };
          reader.readAsText(file);
        }

        function exportCircuit() {
          selectedElements = [];
          redrawCanvas();
          const scaleFactorStr = prompt(
            "Enter resolution scale factor for PNG (e.g., 2 for 2x resolution):",
            "2"
          );
          const scaleFactor = parseFloat(scaleFactorStr);
          if (isNaN(scaleFactor) || scaleFactor <= 0) {
            alert("Invalid scale factor.");
            return;
          }
          const bounds = calculateBoundingBox();
          if (!bounds) {
            alert("Canvas is empty!");
            return;
          }
          const padding = 30;
          const exportCanvas = document.createElement("canvas");
          const exportCtx = exportCanvas.getContext("2d");
          exportCanvas.width =
            (bounds.maxX - bounds.minX + padding * 2) * scaleFactor;
          exportCanvas.height =
            (bounds.maxY - bounds.minY + padding * 2) * scaleFactor;

          const originalCtx = ctx;
          ctx = exportCtx;

          ctx.save();
          ctx.scale(scaleFactor, scaleFactor);
          ctx.translate(-bounds.minX + padding, -bounds.minY + padding);
          circuitElements.forEach((el) => drawElement(el));
          drawJunctions();
          ctx.restore();

          ctx = originalCtx;

          const link = document.createElement("a");
          link.download = "circuit-diagram.png";
          link.href = exportCanvas.toDataURL("image/png");
          link.click();
        }

        saveState();
        redrawCanvas();
      });
    </script>
  </body>
</html>
