<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Circuit Drafter - Effortless circuit schematics</title>
    <!-- Google Material Icons -->
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0&icon_names=folder_open,polyline"
    />
    <!-- Google Material Icons -->

    <!-- Link to Google Font (Outfit) -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Outfit:wght@700&display=swap"
      rel="stylesheet"
    />

    <style>
      body {
        font-family: "Georgia", "Times New Roman", Times, serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 0;
        padding: 20px;
        background-color: #f8f9fa;
        color: #333;
      }
      h1 {
        font-family: "Outfit", sans-serif;
        font-weight: 700;
        color: #212529;
      }
      #toolbar {
        margin-bottom: 20px;
        background: #ffffff;
        padding: 10px;
        border-radius: 12px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
        border: 1px solid #e9ecef;
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      .tool-group {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .tool-btn,
      .action-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 44px;
        height: 44px;
        border: 1px solid #ced4da;
        background-color: #ffffff;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease-out;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        font-size: 24px;
        color: #495057;
      }
      .tool-btn:hover,
      .action-btn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        border-color: #adb5bd;
      }
      .tool-btn:active,
      .action-btn:active:not(:disabled) {
        transform: translateY(1px);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        background-color: #f8f9fa;
        transition-duration: 0.1s;
      }
      .tool-btn.selected,
      .action-btn.selected {
        background-color: #007bff;
        border-color: #007bff;
        color: white;
        box-shadow: 0 2px 5px rgba(0, 123, 255, 0.3);
      }
      .tool-btn svg {
        width: 28px;
        height: 28px;
        stroke-width: 1.5;
        stroke: #495057;
        transition: all 0.2s ease-out;
      }
      /* Universal rule for selected button icons */
      .tool-btn.selected svg,
      .tool-btn.selected .material-icons,
      .tool-btn.selected .material-symbols-outlined,
      .action-btn.selected svg,
      .action-btn.selected .material-icons {
        stroke: white;
        color: white;
      }
      /* Rule for filling shapes within selected icons */
      .tool-btn.selected svg path[fill]:not([fill="none"]) {
        fill: white;
      }
      /* Rule for filling shapes within normal icons */
      .tool-btn svg path[fill]:not([fill="none"]) {
        fill: #495057;
      }
      /* Specific override for select icon arrow */
      .tool-btn #select-icon-arrow {
        fill: #495057;
      }
      .tool-btn.selected #select-icon-arrow {
        fill: white;
      }
      .divider {
        width: 1px;
        height: 35px;
        background-color: #e9ecef;
        margin: 0 8px;
      }
      .action-btn:disabled {
        color: #adb5bd;
        background-color: #e9ecef;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
        border-color: #ced4da;
      }
      /* --- START: Style for the new green file button --- */
      #fileOpsBtn {
        background-color: #28a745;
        border-color: #28a745;
        color: white;
      }
      #fileOpsBtn:hover:not(:disabled) {
        background-color: #218838;
        border-color: #1e7e34;
      }
      /* --- END: Style for the new green file button --- */
      #circuitCanvas {
        border: 1px solid #dee2e6;
        border-radius: 8px;
        background-color: #fff;
      }
      .tool-dropdown {
        position: relative;
        display: inline-block;
      }
      .dropdown-trigger {
        cursor: default;
      }
      .dropdown-content {
        display: flex;
        flex-direction: column;
        gap: 6px;
        position: absolute;
        top: calc(100% + 5px);
        left: 50%;
        transform: translateX(-50%) translateY(-10px);
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        transition: opacity 0.2s ease-out, transform 0.2s ease-out,
          visibility 0.2s;
        background-color: #ffffff;
        padding: 8px;
        border-radius: 8px;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.12);
        border: 1px solid #e9ecef;
        z-index: 10;
      }
      .tool-dropdown:hover .dropdown-content {
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
        transform: translateX(-50%) translateY(0);
      }
      #helpBtn {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 50px;
        height: 50px;
        background-color: #ffffff;
        border-radius: 50%;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        text-decoration: none;
        transition: all 0.2s ease-out;
      }
      #helpBtn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        background-color: #f8f9fa;
      }
      #helpBtn .material-icons {
        font-size: 28px;
        color: #007bff;
      }
      .title-container {
        display: flex;
        align-items: center;
        gap: 15px;
        margin-bottom: 20px;
      }
      .logo {
        height: 75px;
      }
      h1 {
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
        font-weight: 600;
        letter-spacing: 0.5px;
        color: #343a40;
      }
      #tagline {
        margin: 2px 0 0 0;
        font-size: 1.1rem;
        color: #6c757d;
        font-weight: 400;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
      }

      /* --- START: Modal Styles --- */
      .modal-overlay {
        display: none; /* Hidden by default */
        position: fixed;
        z-index: 1001;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.5);
        align-items: center;
        justify-content: center;
      }
      .modal-content {
        background-color: #fefefe;
        margin: auto;
        padding: 20px 30px;
        border: 1px solid #888;
        width: 80%;
        max-width: 600px;
        border-radius: 12px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        position: relative;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
      }
      .modal-close {
        color: #aaa;
        position: absolute;
        top: 10px;
        right: 20px;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
      }
      .modal-close:hover,
      .modal-close:focus {
        color: black;
        text-decoration: none;
      }
      .modal-content h3 {
        margin-top: 0;
        color: #343a40;
      }
      .modal-table-container {
        max-height: 40vh;
        overflow-y: auto;
        margin: 20px 0;
        border: 1px solid #dee2e6;
        border-radius: 8px;
      }
      #bulk-input-table {
        width: 100%;
        border-collapse: collapse;
      }
      #bulk-input-table th,
      #bulk-input-table td {
        border-bottom: 1px solid #dee2e6;
        padding: 12px;
        text-align: left;
      }
      #bulk-input-table th {
        background-color: #f8f9fa;
        position: sticky;
        top: 0;
      }
      #bulk-input-table td input {
        width: 95%;
        padding: 8px;
        border: 1px solid #ced4da;
        border-radius: 4px;
        font-size: 14px;
      }
      #bulk-input-table .delete-row-btn {
        background: none;
        border: none;
        color: #dc3545;
        cursor: pointer;
        font-size: 24px;
        line-height: 1;
        padding: 0 5px;
      }
      .modal-actions {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        margin-top: 20px;
      }
      .modal-button {
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-weight: 500;
        transition: background-color 0.2s;
        font-size: 1rem;
      }
      .modal-button.primary {
        background-color: #007bff;
        color: white;
      }
      .modal-button.primary:hover {
        background-color: #0056b3;
      }
      .modal-button.secondary {
        background-color: #6c757d;
        color: white;
      }
      .modal-button.secondary:hover {
        background-color: #5a6268;
      }
      #add-row-btn {
        background-color: #28a745;
        color: white;
      }
      #add-row-btn:hover {
        background-color: #218838;
      }
      /* Style for textareas */
      #bulk-text-input,
      #text-input-area {
        width: 98%;
        min-height: 120px;
        margin-top: 10px;
        padding: 10px;
        border: 1px solid #ced4da;
        border-radius: 8px;
        font-size: 1rem;
        font-family: inherit;
        resize: vertical;
      }
      /* --- START: Style for new Text Modal Options --- */
      .text-modal-options {
        margin-top: 15px;
        display: flex;
        align-items: center;
      }
      .text-modal-options label {
        display: flex;
        align-items: center;
        cursor: pointer;
        font-size: 0.95rem;
        color: #495057;
      }
      .text-modal-options input[type="checkbox"] {
        margin-right: 8px;
        /* Simple styling for the checkbox */
        width: 16px;
        height: 16px;
      }
      /* --- END: Style for new Text Modal Options --- */

      /* --- START: Component Transform Modal Styles --- */
      .transform-options-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
        margin: 20px 0;
      }
      .transform-options-container label:not(.transform-checkbox-label) {
        font-weight: 500;
        color: #495057;
      }
      .modal-input-field {
        width: 95%;
        padding: 8px;
        border: 1px solid #ced4da;
        border-radius: 4px;
        font-size: 14px;
      }
      .transform-checkbox-label {
        display: flex;
        align-items: center;
        cursor: pointer;
        font-size: 0.95rem;
        color: #495057;
      }
      .transform-checkbox-label input[type="checkbox"] {
        margin-right: 10px;
        width: 16px;
        height: 16px;
      }
       /* New styles for scaling section */
      .scale-section {
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px solid #e0e0e0;
      }
      .scale-input-group {
        display: flex;
        gap: 20px;
        align-items: center;
        margin-top: 10px;
      }
      .scale-input-group > div {
        flex: 1;
      }
      .modal-input-field:disabled {
        background-color: #e9ecef;
        cursor: not-allowed;
      }
      /* --- END: Component Transform Modal Styles --- */
      /* --- END: Modal Styles --- */
    </style>
  </head>
  <body>
    <div class="title-container">
      <img
        src="https://github.com/user-attachments/assets/29b49b83-8617-48fc-aabf-a31d292b27f1"
        alt="Circuit Drafter Logo"
        class="logo"
      />
      <div>
        <h1>Circuit Drafter (V0.48b)</h1>
        <p id="tagline">Effortless circuit schematics.</p>
      </div>
    </div>

    <a
      href="https://github.com/inverter3p/circuitdrafter/blob/main/README.md"
      target="_blank"
      rel="noopener noreferrer"
      id="helpBtn"
      title="Help / View Documentation"
    >
      <i class="material-icons">help_outline</i>
    </a>

    <div id="toolbar">
      <div class="tool-group">
        <button class="tool-btn" id="tool-select" title="Select/Move (S)">
          <svg viewBox="0 0 24 24">
            <path
              id="select-icon-box"
              d="M9 14 v7 h12 v-12 h-7"
              stroke-width="2"
              stroke-dasharray="3"
              fill="none"
              stroke-linecap="round"
            />
            <path id="select-icon-arrow" d="M4 3 L15 12 L11 14 L4 3Z" />
          </svg>
        </button>
        <!-- START: Wire Dropdown -->
        <div class="tool-dropdown">
           <button class="tool-btn dropdown-trigger" title="Wire Tools">
             <svg viewBox="0 0 24 24">
               <path
                 d="M4 12 L20 12"
                 fill="none"
                 stroke-linejoin="round"
                 stroke-linecap="round"
               ></path>
               <circle cx="4" cy="12" r="2" stroke="red" fill="red" />
               <circle cx="20" cy="12" r="2" stroke="red" fill="red" />
             </svg>
           </button>
           <div class="dropdown-content">
              <button
                class="tool-btn"
                id="tool-wire"
                title="Wire (W, Shift for straight line, Ctrl+Click for dot)"
              >
                <svg viewBox="0 0 24 24">
                  <path
                    d="M4 12 L20 12"
                    fill="none"
                    stroke-linejoin="round"
                    stroke-linecap="round"
                  ></path>
                  <circle cx="4" cy="12" r="2" stroke="red" fill="red" />
                  <circle cx="20" cy="12" r="2" stroke="red" fill="red" />
                </svg>
              </button>
              <button class="tool-btn" id="tool-path-wire" title="Path Wire (P)">
                 <i class="material-symbols-outlined">polyline</i>
              </button>
           </div>
        </div>
        <!-- END: Wire Dropdown -->
        <button class="tool-btn" id="tool-text" title="Text (T)">
          <i class="material-icons">text_fields</i>
        </button>
      </div>
      <div class="divider"></div>
      <div class="tool-group">
        <!-- START: RLC Dropdown -->
        <div class="tool-dropdown">
          <button class="tool-btn dropdown-trigger" title="Passive Components">
            <svg viewBox="-2 -10 34 20">
              <path
                d="M0,0 H4 L6,-6 L10,6 L14,-6 L18,6 L22,-6 L26,6 L28,0 H32"
                fill="none"
                stroke-linejoin="round"
                stroke-linecap="round"
              ></path>
            </svg>
          </button>
          <div class="dropdown-content">
            <button class="tool-btn" id="tool-resistor" title="Resistor">
              <svg viewBox="-2 -10 34 20">
                <path
                  d="M0,0 H4 L6,-6 L10,6 L14,-6 L18,6 L22,-6 L26,6 L28,0 H32"
                  fill="none"
                  stroke-linejoin="round"
                  stroke-linecap="round"
                ></path>
              </svg>
            </button>
            <button class="tool-btn" id="tool-capacitor" title="Capacitor">
              <svg viewBox="-5 -10 30 20">
                <path
                  d="M0,0 H10 M10,-8 V8 M15,-8 V8 M15,0 H25"
                  fill="none"
                  stroke-linecap="round"
                ></path>
              </svg>
            </button>
            <button class="tool-btn" id="tool-inductor" title="Inductor">
              <svg viewBox="-2 -10 34 20">
                <path
                  d="M0,0 H6 C9,-13 12,-13 15,1 C18,-13 21,-13 24,0 H32"
                  fill="none"
                  stroke-linecap="round"
                ></path>
              </svg>
            </button>
          </div>
        </div>
        <!-- END: RLC Dropdown -->
        <div class="tool-dropdown">
          <button class="tool-btn dropdown-trigger" title="Diodes">
            <svg viewBox="-2 -10 24 20">
              <path
                d="M-4,0 H12 M16,0 H22"
                fill="none"
                stroke-linejoin="round"
                stroke-linecap="round"
              />
              <path fill="#495057" d="M5,-6 V6 L16,0 Z" />
              <path
                d="M16,-6 V6"
                fill="none"
                stroke-linejoin="round"
                stroke-linecap="round"
              />
            </svg>
          </button>
          <div class="dropdown-content">
            <button class="tool-btn" id="tool-diode" title="Diode">
              <svg viewBox="-2 -10 24 20">
                <path
                  d="M-4,0 H12 M16,0 H22"
                  fill="none"
                  stroke-linejoin="round"
                  stroke-linecap="round"
                />
                <path fill="#495057" d="M5,-6 V6 L16,0 Z" />
                <path
                  d="M16,-6 V6"
                  fill="none"
                  stroke-linejoin="round"
                  stroke-linecap="round"
                />
              </svg>
            </button>
            <button class="tool-btn" id="tool-zener" title="Zener Diode">
              <svg viewBox="-2 -12 24 24">
                <path
                  d="M-4,0 H12 M16,0 H22"
                  fill="none"
                  stroke-linejoin="round"
                  stroke-linecap="round"
                />
                <path fill="#495057" d="M5,-6 V6 L16,0 Z" />
                <path
                  d="M16,-6 V6"
                  fill="none"
                  stroke-linejoin="round"
                  stroke-linecap="round"
                />
                <path d="M16,-6 L13,-8 M16,6 L19,8" stroke-linecap="round" />
              </svg>
            </button>
            <button class="tool-btn" id="tool-led" title="LED">
              <svg viewBox="-2 -16 26 26">
                <path d="M-4,0 H12 M16,0 H22" fill="none" />
                <path d="M5,-6 V6 L16,0 Z" fill="#495057" />
                <path d="M16,-6 V6" fill="none" />
                <path
                  d="M10,-10 L15,-15 M13,-15 H15 V-13"
                  fill="none"
                  stroke-linecap="round"
                />
                <path
                  d="M14,-8 L19,-13 M17,-13 H19 V-11"
                  fill="none"
                  stroke-linecap="round"
                />
              </svg>
            </button>
            <button
              class="tool-btn"
              id="tool-fwd"
              title="FWD"
              style="font-size: 14px; font-weight: bold"
            >
              FWD
            </button>
          </div>
        </div>
        <!-- START: Transistors Dropdown -->
        <div class="tool-dropdown">
          <button class="tool-btn dropdown-trigger" title="Transistors">
            <svg viewBox="-20 -20 40 40">
              <path
                d="M -20 0 h 10 M -10 -10 v 20 M 5 -18 v 6 M 5 -12 L -10 -5 M 5 18 v -6 M 5 12 L -10 5"
                fill="none"
                stroke-linecap="round"
                stroke-linejoin="round"
              ></path>
              <path fill="#495057" d="M5 12 L0 5 L -3 12 Z" />
            </svg>
          </button>
          <div class="dropdown-content">
            <button
              class="tool-btn"
              id="tool-npn"
              title="NPN"
              style="font-size: 14px; font-weight: bold"
            >
              <svg viewBox="-20 -20 40 40">
              <path
                d="M -20 0 h 10 M -10 -10 v 20 M 5 -18 v 6 M 5 -12 L -10 -5 M 5 18 v -6 M 5 12 L -10 5"
                fill="none"
                stroke-linecap="round"
                stroke-linejoin="round"
              ></path>
              <path fill="#495057" d="M5 12 L0 5 L -3 12 Z" />
            </svg>
            </button>
            <button
              class="tool-btn"
              id="tool-pnp"
              title="PNP"
              style="font-size: 14px; font-weight: bold"
            >
              <svg viewBox="-20 -20 40 40">
              <path
                d="M -20 0 h 10 M -10 -10 v 20 M 5 -18 v 6 M 5 -12 L -10 -5 M 5 18 v -6 M 5 12 L -10 5"
                fill="none"
                stroke-linecap="round"
                stroke-linejoin="round"
              ></path>
              <path fill="#495057" d="M-10 -5 L0 -5 L -3 -12 z" />
            </svg>
            </button>
            <button
              class="tool-btn"
              id="tool-nfet"
              title="N-CH"
              style="font-size: 12px; font-weight: bold"
            >
              N-CH
            </button>
            <button
              class="tool-btn"
              id="tool-pfet"
              title="N-CH"
              style="font-size: 12px; font-weight: bold"
            >
              P-CH
            </button>
            <button
              class="tool-btn"
              id="tool-igbt"
              title="IGBT"
              style="font-size: 14px; font-weight: bold"
            >
              IGBT
            </button>
            <button
              class="tool-btn"
              id="tool-opamp"
              title="OPAMP"
              style="font-size: 14px;font-weight: bold"
            >
              OP-AMP
            </button>
          </div>
        </div>
        <!-- END: Switches & Transistors Dropdown -->
      </div>
      <div class="divider"></div>
      <div class="tool-group">
        <div class="tool-dropdown">
          <button class="tool-btn dropdown-trigger" title="Sources">
            <svg viewBox="-12 -12 24 24">
              <circle cx="0" cy="0" r="10" fill="none"></circle>
              <path d="M-3,-3 H4 M0,-7 V1, M-3,3 H4" fill="none"></path>
            </svg>
          </button>
          <div class="dropdown-content">
            <button
              class="tool-btn"
              id="tool-voltage"
              title="Voltage Source (DC)"
            >
              <svg viewBox="-12 -12 24 24">
                <circle cx="0" cy="0" r="10" fill="none"></circle>
                <path d="M-3,-3 H4 M0,-7 V1, M-3,3 H4" fill="none"></path>
              </svg>
            </button>
            <button
              class="tool-btn"
              id="tool-acvoltage"
              title="Voltage Source (AC)"
            >
              <svg viewBox="-12 -12 24 24">
                <circle cx="0" cy="0" r="10" fill="none"></circle>
                <path
                  d="M-8,0 Q-4,-10 0,0 T8,0"
                  fill="none"
                  stroke-linecap="round"
                ></path>
              </svg>
            </button>
            <button
              class="tool-btn"
              id="tool-currentsource"
              title="Current Source"
            >
              <svg viewBox="-12 -12 24 24">
                <circle cx="0" cy="0" r="10" fill="none"></circle>
                <path
                  d="M0,7 L0,-7 M-4,-2 L0,-7 L4,-2"
                  fill="none"
                  stroke-linecap="round"
                ></path>
              </svg>
            </button>
            <button
              class="tool-btn"
              id="tool-dependent_voltage"
              title="Dependent Voltage Source"
            >
              <svg viewBox="-12 -12 24 24">
                <path d="M0 -10 L10 0 L0 10 L-10 0 Z" fill="none"></path>
                <!-- Plus sign -->
                <path d="M-2.5 -5 L2.5 -5 M0 -7.5 L0 -2.5" fill="none"></path>
                <!-- Minus sign -->
                <path d="M-2.5 5 L2.5 5" fill="none"></path>
              </svg>
            </button>
            <button
              class="tool-btn"
              id="tool-dependent_current"
              title="Dependent Current Source"
            >
              <svg viewBox="-12 -12 24 24">
                <path d="M0 -10 L10 0 L0 10 L-10 0 Z" fill="none"></path>
                <!-- Arrow -->
                <path
                  d="M0 6 L0 -6 M-3 -2 L0 -6 L3 -2"
                  fill="none"
                  stroke-linecap="round"
                ></path>
              </svg>
            </button>
            <button class="tool-btn" id="tool-battery" title="Battery">
              <svg viewBox="-10 -10 20 20">
                <path
                  d="M-8,-8 H8 M-4,-3 H4 M-8,3 H8 M-4,8 H4"
                  stroke-width="1.5"
                  fill="none"
                ></path>
              </svg>
            </button>
            <button class="tool-btn" id="tool-gnd" title="Ground">
              <svg viewBox="-10 -2 20 14">
                <path
                  d="M0,0 V8 M-8,8 H8 M-5,11 H5 M-2,14 H2"
                  fill="none"
                  stroke-linecap="round"
                ></path>
              </svg>
            </button>
          </div>
        </div>
      </div>
      <!-- START: Switches  Dropdown -->
      <div class="tool-dropdown">
        <button
          class="tool-btn dropdown-trigger"
          title="Switches & Transistors"
        >
          <svg viewBox="-45 -20 50 40">
            <path
              d="M-40,0 L-30,0 M-8, 0 L10,0 M-30,0 L-8,-18"
              stroke-width="2.5"
              fill="none"
              stroke-linecap="round"
            />
            <circle cx="-30" cy="0" r="4" stroke-width="1.5" fill="white" />
            <circle cx="-8" cy="0" r="4" stroke-width="1.5" fill="white" />
          </svg>
        </button>
        <div class="dropdown-content">
          <button
            class="tool-btn"
            id="tool-switch"
            title="Switch (SPST - Double-click to toggle)"
          >
            <svg viewBox="-45 -20 50 40">
              <path
                d="M-40,0 L-30,0 M-8, 0 L10,0 M-30,0 L-8,-18"
                stroke-width="2.5"
                fill="none"
                stroke-linecap="round"
              />
              <circle cx="-30" cy="0" r="4" stroke-width="1.5" fill="white" />
              <circle cx="-8" cy="0" r="4" stroke-width="1.5" fill="white" />
            </svg>
          </button>
          <button
            class="tool-btn"
            id="tool-spdtSwitch"
            title="2-Way Switch (SPDT - Double-click to toggle)"
          >
            <svg viewBox="-45 -20 50 40">
              <path
                d="M-40,0 L-30,0 M-8, -12 L10,-12 M-8, 12 L10,12 M-30,0 L-8,-18"
                stroke-width="2.5"
                fill="none"
                stroke-linecap="round"
              />
              <circle cx="-30" cy="0" r="4" stroke-width="1.5" fill="white" />
              <circle cx="-8" cy="-12" r="4" stroke-width="1.5" fill="white" />
              <circle cx="-8" cy="12" r="4" stroke-width="1.5" fill="white" />
            </svg>
          </button>
        </div>
      </div>
      <!-- END: Switches & Transistors Dropdown -->
      <div class="divider"></div>
      <div class="tool-group">
        <button class="action-btn" id="undoBtn" title="Undo (Ctrl+Z)">
          <i class="material-icons">undo</i>
        </button>
        <button class="action-btn" id="redoBtn" title="Redo (Ctrl+Y)">
          <i class="material-icons">redo</i>
        </button>
        <button
          class="action-btn"
          id="copyBtn"
          title="Duplicate Selected (Ctrl+D)"
        >
          <i class="material-icons">content_copy</i>
        </button>
        <button class="action-btn" id="rotateBtn" title="Rotate Selected (R)">
          <i class="material-icons">rotate_right</i>
        </button>
        <button class="action-btn" id="deleteBtn" title="Delete Selected (Del)">
          <i class="material-icons">delete</i>
        </button>
      </div>
      <div class="divider"></div>
      <!-- START: Bulk Operations (Moved) -->
      <div class="tool-group">
        <button class="action-btn" id="bulkAddBtn" title="Bulk Add Components">
          <i class="material-icons">playlist_add</i>
        </button>
        <button
          class="action-btn"
          id="bulkTextBtn"
          title="Bulk Add Text Labels"
        >
          <i class="material-icons">format_list_bulleted_add</i>
        </button>
      </div>
      <!-- END: Bulk Operations -->
      <div class="divider"></div>
      <!-- START: File Operations Dropdown (Moved) -->
      <div class="tool-dropdown">
        <button
          id="fileOpsBtn"
          class="action-btn dropdown-trigger"
          title="File Operations"
        >
          <i class="material-icons">save</i>
        </button>
        <div class="dropdown-content">
          <button
            class="action-btn"
            id="saveExportBtn"
            title="Save or Export... (Ctrl+S)"
          >
            <i class="material-icons">save_alt</i>
          </button>
          <button class="action-btn" id="loadBtn" title="Load File (Ctrl+O)">
            <i class="material-symbols-outlined">folder_open</i>
          </button>
          <!-- ===== GEMINI BUTTON START ===== -->
          <button
            class="action-btn"
            id="geminiAIBtn"
            title="Generate Circuit with AI"
          >
            <i class="material-icons">auto_awesome</i>
          </button>
          <!-- ===== GEMINI BUTTON END ===== -->
        </div>
      </div>
      <!-- END: File Operations Dropdown -->
    </div>

    <canvas id="circuitCanvas" width="1000" height="700"></canvas>
    <input type="file" id="fileInput" accept=".json" style="display: none" />

    <!-- START: Bulk Add Components Modal -->
    <div id="bulkAddModal" class="modal-overlay">
      <div class="modal-content">
        <span class="modal-close" id="bulkAddModalClose">&times;</span>
        <h3>Bulk Add Components</h3>
        <p>
          Valid names: R, L, C, D, ZD, LED, SW, SPDT, Vdc, Vac, Idc, DVS, DCS,
          GND, Batt, IGBT, NPN, PNP, NFET,PFET, OPAMP.
        </p>
        <div class="modal-table-container">
          <table id="bulk-input-table">
            <thead>
              <tr>
                <th>Component Name</th>
                <th>Quantity</th>
                <th>Auto-Label? (Y/N)</th>
                <th></th>
              </tr>
            </thead>
            <tbody>
              <!-- Rows will be added here by JavaScript -->
            </tbody>
          </table>
        </div>
        <button id="add-row-btn" class="modal-button">Add Another Row</button>
        <div class="modal-actions">
          <button id="bulk-cancel-btn" class="modal-button secondary">
            Cancel
          </button>
          <button id="bulk-place-btn" class="modal-button primary">
            Place Components
          </button>
        </div>
      </div>
    </div>
    <!-- END: Bulk Add Components Modal -->

    <!-- START: Bulk Add Text Modal -->
    <div id="bulkTextModal" class="modal-overlay">
      <div class="modal-content">
        <span class="modal-close" id="bulkTextModalClose">&times;</span>
        <h3>Bulk Add Text</h3>
        <p>
          Enter text labels separated by a semicolon (;), OR paste a full
          circuit JSON to append it below the current drawing.
        </p>
        <textarea
          id="bulk-text-input"
          placeholder="Label 1; Label 2; V_in = 5V; ..."
        ></textarea>
        <div class="modal-actions">
          <button id="bulk-text-cancel-btn" class="modal-button secondary">
            Cancel
          </button>
          <button id="bulk-text-place-btn" class="modal-button primary">
            Place Text
          </button>
        </div>
      </div>
    </div>
    <!-- END: Bulk Add Text Modal -->

    <!-- START: Text Input Modal -->
    <div id="textInputModal" class="modal-overlay">
      <div class="modal-content">
        <span class="modal-close" id="textInputModalClose">&times;</span>
        <h3>Add / Edit Text Label</h3>
        <p>Use LaTeX style: V_{in}, R^2, \frac{num}{den}, \mu, etc.</p>
        <p>
          Wrap math expression inside &...& to evaluate the numerical value:
          &(1/15)+8**2&.
        </p>
        <textarea
          id="text-input-area"
          placeholder="Enter text here..."
        ></textarea>
        <div class="text-modal-options">
          <label>
            <input type="checkbox" id="text-italic-checkbox" checked />
            <span>Use Italic Font</span>
          </label>
        </div>
        <div class="modal-actions">
          <button id="text-modal-cancel-btn" class="modal-button secondary">
            Cancel
          </button>
          <button id="text-modal-ok-btn" class="modal-button primary">
            OK
          </button>
        </div>
      </div>
    </div>
    <!-- END: Text Input Modal -->

    <!-- START: Component Transform Modal -->
    <div id="transformModal" class="modal-overlay">
        <div class="modal-content">
            <span class="modal-close" id="transformModalClose">&times;</span>
            <h3>Transform Component</h3>
            <div class="transform-options-container">
                <div>
                    <label for="transform-rotation-input">Rotation (degrees):</label>
                    <input type="number" id="transform-rotation-input" step="45" class="modal-input-field" />
                </div>

                <label class="transform-checkbox-label">
                    <input type="checkbox" id="transform-flipH-checkbox" />
                    <span>Flip Horizontally</span>
                </label>

                <label class="transform-checkbox-label">
                    <input type="checkbox" id="transform-flipV-checkbox" />
                    <span>Flip Vertically</span>
                </label>
                
                <div class="scale-section">
                    <label class="transform-checkbox-label">
                        <input type="checkbox" id="transform-scale-checkbox" />
                        <span>Scale Component (maintains aspect ratio)</span>
                    </label>
                    <div class="scale-input-group">
                        <div>
                            <label for="transform-width-input">New Width (multiple of 5):</label>
                            <input type="number" id="transform-width-input" step="5" min="5" class="modal-input-field" disabled />
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-actions">
                <button id="transform-modal-cancel-btn" class="modal-button secondary">
                    Cancel
                </button>
                <button id="transform-modal-ok-btn" class="modal-button primary">
                    OK
                </button>
            </div>
        </div>
    </div>
    <!-- END: Component Transform Modal -->

    <script>
      /****************************************************************************
      * Circuit Drafter - V0.48b (Date: 2025-08-11)
       *   - Path Wire tool is able to draw box triangle and circle. 
      * Circuit Drafter - V0.43a (Date: 2025-08-07)
       *   - Add Path Wire tool for command-based wire drawing.
       * Circuit Drafter - V0.42aR (Date: 2025-08-07)
       *   - Apply scaling transform to components.
       *   - Refactored all drawing functions to respect custom component width/height.
       *   - Add NPN PNP MOSFET and OPAMP
       *   - Add draw by AI button
       * Circuit Drafter - V0.32R (Date: 2025-07-24)
       *   - Math expression can be evaluated inside &.....&
       *   - Add dependent sources.
       *   - Double click component to direct edit rotation value.
       ****************************************************************************/
      document.addEventListener("DOMContentLoaded", () => {
        let canvas = document.getElementById("circuitCanvas");
        let ctx = canvas.getContext("2d");
        const fileInput = document.getElementById("fileInput");

        const bulkAddBtn = document.getElementById("bulkAddBtn");
        const bulkAddModal = document.getElementById("bulkAddModal");
        const bulkAddModalClose = document.getElementById("bulkAddModalClose");
        const addRowBtn = document.getElementById("add-row-btn");
        const bulkPlaceBtn = document.getElementById("bulk-place-btn");
        const bulkCancelBtn = document.getElementById("bulk-cancel-btn");
        const bulkInputTableBody = document.querySelector(
          "#bulk-input-table tbody"
        );
        const bulkTextBtn = document.getElementById("bulkTextBtn");
        const bulkTextModal = document.getElementById("bulkTextModal");
        const bulkTextModalClose =
          document.getElementById("bulkTextModalClose");
        const bulkTextInput = document.getElementById("bulk-text-input");
        const bulkTextPlaceBtn = document.getElementById("bulk-text-place-btn");
        const bulkTextCancelBtn = document.getElementById(
          "bulk-text-cancel-btn"
        );
        const textInputModal = document.getElementById("textInputModal");
        const textInputModalClose = document.getElementById(
          "textInputModalClose"
        );
        const textInputArea = document.getElementById("text-input-area");
        const textItalicCheckbox = document.getElementById(
          "text-italic-checkbox"
        );
        const textModalOkBtn = document.getElementById("text-modal-ok-btn");
        const textModalCancelBtn = document.getElementById(
          "text-modal-cancel-btn"
        );
        const geminiAIBtn = document.getElementById("geminiAIBtn");
        const transformModal = document.getElementById("transformModal");
        const transformModalClose = document.getElementById("transformModalClose");
        const transformRotationInput = document.getElementById("transform-rotation-input");
        const transformFlipHCheckbox = document.getElementById("transform-flipH-checkbox");
        const transformFlipVCheckbox = document.getElementById("transform-flipV-checkbox");
        const transformScaleCheckbox = document.getElementById("transform-scale-checkbox");
        const transformWidthInput = document.getElementById("transform-width-input");
        const transformModalOkBtn = document.getElementById("transform-modal-ok-btn");
        const transformModalCancelBtn = document.getElementById("transform-modal-cancel-btn");

        let autoLabelCounters = {};
        const shortNameToType = {
          R: "resistor", L: "inductor", C: "capacitor", D: "diode", ZD: "zener",
          LED: "led", FWD: "fwd", SW: "switch", SPDT: "spdtSwitch", IGBT: "igbt",
          OPAMP: "opamp", NFET: "nfet", PFET: "pfet", NPN: "npn", PNP: "pnp",
          VDC: "voltage", VAC: "acvoltage", IDC: "currentsource", DVS: "dependent_voltage",
          DCS: "dependent_current", GND: "gnd", BATT: "battery", ARROW: "arrow_marker",
        };
        const shortNameToTypeCI = Object.keys(shortNameToType).reduce(
          (acc, key) => {
            acc[key.toUpperCase()] = shortNameToType[key];
            return acc;
          },
          {}
        );

        let selectedTool = "select";
        let isDrawingWire = false, isDragging = false, isShiftDown = false;
        let wireStartPoint = null, currentMousePos = { x: 0, y: 0 }, dragStartPoint = null;
        let circuitElements = [];
        let nextId = 0;
        const gridSize = 20, snapTolerance = 12, textFontSize = 16;
        const fineGridSize = gridSize / 8;
        let history = [], historyIndex = -1;
        let selectedElements = [];
        let isMarqueeSelecting = false;
        let marqueeStartPoint = null;
        let hoveredWireSegment = null;

        const componentData = {
          resistor: { width: 80, height: 30, terminals: [{ x: -40, y: 0 }, { x: 40, y: 0 }] },
          capacitor: { width: 80, height: 30, terminals: [{ x: -40, y: 0 }, { x: 40, y: 0 }] },
          inductor: { width: 80, height: 30, terminals: [{ x: -40, y: 0 }, { x: 40, y: 0 }] },
          diode: { width: 60, height: 30, terminals: [{ x: -30, y: 0 }, { x: 30, y: 0 }] },
          fwd: { width: 60, height: 30, terminals: [{ x: -30, y: 0 }, { x: 30, y: 0 }] },
          zener: { width: 60, height: 34, terminals: [{ x: -30, y: 0 }, { x: 30, y: 0 }] },
          led: { width: 60, height: 50, terminals: [{ x: -30, y: 0 }, { x: 30, y: 0 }] },
          switch: { width: 80, height: 30, terminals: [{ x: -40, y: 0 }, { x: 40, y: 0 }] },
          spdtSwitch: { width: 80, height: 60, terminals: [{ x: -40, y: 0 }, { x: 40, y: -20 }, { x: 40, y: 20 }] },
          igbt: { width: 60, height: 105, terminals: [{ x: 30, y: -52.5 }, { x: 30, y: 52.5 }, { x: -30, y: 12.5 }] },
          opamp: { width: 140, height: 100, terminals: [{ x: -70, y: -20 }, { x: -70, y: 20 }, { x: 70, y: 0 }] },
          nfet: { width: 60, height: 105, terminals: [{ x: 30, y: -52.5 }, { x: 30, y: 52.5 }, { x: -30, y: 12.5 }] },
          pfet: { width: 60, height: 105, terminals: [{ x: 30, y: -52.5 }, { x: 30, y: 52.5 }, { x: -30, y: 12.5 }] },
          npn: { width: 60, height: 105, terminals: [{ x: 30, y: -52.5 }, { x: 30, y: 52.5 }, { x: -30, y: 0 }] },
          pnp: { width: 60, height: 105, terminals: [{ x: 30, y: -52.5 }, { x: 30, y: 52.5 }, { x: -30, y: 0 }] },
          voltage: { width: 35, height: 60, terminals: [{ x: 0, y: -30 }, { x: 0, y: 30 }] },
          acvoltage: { width: 35, height: 60, terminals: [{ x: 0, y: -30 }, { x: 0, y: 30 }] },
          currentsource: { width: 35, height: 60, terminals: [{ x: 0, y: -30 }, { x: 0, y: 30 }] },
          dependent_voltage: { width: 40, height: 60, terminals: [{ x: 0, y: -30 }, { x: 0, y: 30 }] },
          dependent_current: { width: 40, height: 60, terminals: [{ x: 0, y: -30 }, { x: 0, y: 30 }] },
          battery: { width: 40, height: 60, terminals: [{ x: 0, y: -30 }, { x: 0, y: 30 }] },
          gnd: { width: 30, height: 25, terminals: [{ x: 0, y: -10 }] },
          arrow_marker: { width: 16, height: 10, terminals: [] },
        };

        const actionButtons = {
          undo: document.getElementById("undoBtn"), redo: document.getElementById("redoBtn"),
          copy: document.getElementById("copyBtn"), rotate: document.getElementById("rotateBtn"),
          delete: document.getElementById("deleteBtn"),
        };
        
        function getDimensionsAndScale(el) {
            const defaultDims = componentData[el.type];
            if (!defaultDims) return { width: 0, height: 0, scale: 1 };

            const currentWidth = (el && el.width) ? el.width : defaultDims.width;
            
            let newHeight;
            let scale;

            if (defaultDims.width > 0) {
                const aspectRatio = defaultDims.height / defaultDims.width;
                newHeight = currentWidth * aspectRatio;
                scale = currentWidth / defaultDims.width;
            } else {
                newHeight = defaultDims.height;
                scale = 1;
            }

            return { width: currentWidth, height: newHeight, scale: scale };
        }

        function updateToolbar() {
          document.querySelectorAll(".tool-btn, .action-btn").forEach((btn) => btn.classList.remove("selected"));
          const currentToolButton = document.getElementById(`tool-${selectedTool}`);
          if (currentToolButton) {
            currentToolButton.classList.add("selected");
            const parentDropdown = currentToolButton.closest(".tool-dropdown");
            if (parentDropdown) parentDropdown.querySelector(".dropdown-trigger").classList.add("selected");
          }
          actionButtons.undo.disabled = historyIndex <= 0;
          actionButtons.redo.disabled = historyIndex >= history.length - 1;
          const isComponentSelected = selectedElements.some(el => el.type !== "wire" && el.type !== "text" && el.type !== "junction" && el.type !== "open_terminal" && el.type !== "path-wire");
          actionButtons.rotate.disabled = !isComponentSelected;
          actionButtons.copy.disabled = selectedElements.length === 0;
          actionButtons.delete.disabled = selectedElements.length === 0;
          canvas.style.cursor = selectedTool === "select" ? "default" : "crosshair";
        }

        document.getElementById("toolbar").addEventListener("click", (e) => {
          const target = e.target.closest("button");
          if (!target || target.disabled) return;
          if (target.classList.contains("tool-btn") && !target.classList.contains("dropdown-trigger")) {
            selectedTool = target.id.replace("tool-", "");
            if (selectedTool !== "select") selectedElements = [];
          } else if (target.id === "undoBtn") undo();
          else if (target.id === "redoBtn") redo();
          else if (target.id === "copyBtn") copySelected();
          else if (target.id === "rotateBtn") rotateSelected();
          else if (target.id === "deleteBtn") deleteSelected();
          else if (target.id === "saveExportBtn") handleSaveExport();
          else if (target.id === "loadBtn") fileInput.click();
          redrawCanvas();
        });

        window.addEventListener("keydown", (e) => {
          if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
          if (e.key === "Shift") isShiftDown = true;
          else if (e.altKey && e.key.toLowerCase() === "c") {
            e.preventDefault();
            if (selectedElements.length > 0) {
              selectedElements.forEach((el) => {
                if (el.color === "red") { delete el.color; } else { el.color = "red"; }
              });
              saveState();
              redrawCanvas();
            }
          }

          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            switch (e.key.toLowerCase()) {
              case "z": undo(); break;
              case "y": redo(); break;
              case "d": copySelected(); break;
              case "s": handleSaveExport(); break;
              case "o": fileInput.click(); break;
            }
          } else {
            switch (e.key.toLowerCase()) {
              case "r": if (selectedElements.length > 0) { e.preventDefault(); rotateSelected(); } break;
              case "delete": case "backspace": if (selectedElements.length > 0) { e.preventDefault(); deleteSelected(); } break;
              case "w": selectedTool = "wire"; break;
              case "p": selectedTool = "path-wire"; break;
              case "s": selectedTool = "select"; break;
              case "t": selectedTool = "text"; break;
            }
          }
          redrawCanvas();
        });

        window.addEventListener("keyup", (e) => { if (e.key === "Shift") { isShiftDown = false; redrawCanvas(); } });
        window.addEventListener("blur", () => { isShiftDown = false; });
        fileInput.addEventListener("change", handleFileLoad);

        bulkAddBtn.addEventListener("click", openBulkAddModal);
        bulkAddModalClose.addEventListener("click", closeBulkAddModal);
        bulkCancelBtn.addEventListener("click", closeBulkAddModal);
        addRowBtn.addEventListener("click", () => addBulkRow());
        bulkPlaceBtn.addEventListener("click", handleBulkPlace);
        bulkInputTableBody.addEventListener("click", (e) => { if (e.target.classList.contains("delete-row-btn")) { e.target.closest("tr").remove(); } });
        bulkTextBtn.addEventListener("click", openBulkTextModal);
        bulkTextModalClose.addEventListener("click", closeBulkTextModal);
        bulkTextCancelBtn.addEventListener("click", closeBulkTextModal);
        bulkTextPlaceBtn.addEventListener("click", handleBulkTextPlace);

        window.addEventListener("click", (event) => {
          if (event.target == bulkAddModal) closeBulkAddModal();
          if (event.target == bulkTextModal) closeBulkTextModal();
        });

        function saveState() {
          history = history.slice(0, historyIndex + 1);
          const cleanState = JSON.parse(JSON.stringify(circuitElements, (key, value) => key === "dragInitialState" ? undefined : value));
          history.push(cleanState);
          historyIndex++;
          updateToolbar();
        }
        function undo() { if (historyIndex > 0) { historyIndex--; setState(); } }
        function redo() { if (historyIndex < history.length - 1) { historyIndex++; setState(); } }
        function setState() { circuitElements = JSON.parse(JSON.stringify(history[historyIndex])); selectedElements = []; redrawCanvas(); }
        
        function copySelected() {
          if (selectedElements.length === 0) return;
          const newSelection = [];
          const offset = gridSize;
          selectedElements.forEach((el) => {
            const newEl = JSON.parse(JSON.stringify(el));
            newEl.id = nextId++;
            if (newEl.type === "wire") {
              newEl.start.x += offset; newEl.start.y += offset;
              newEl.end.x += offset; newEl.end.y += offset;
            } else if (newEl.type === "path-wire") {
                newEl.points.forEach(p => { p.x += offset; p.y += offset; });
            } else { 
                newEl.x += offset; newEl.y += offset; 
            }
            circuitElements.push(newEl);
            newSelection.push(newEl);
          });
          selectedElements = newSelection;
          saveState();
          redrawCanvas();
        }

        function rotateSelected() {
          if (selectedElements.length === 0) return;
          selectedElements.forEach((el) => {
            if (el.type !== "wire" && el.type !== "path-wire" && el.type !== "text" && el.type !== "junction" && el.type !== "open_terminal") {
              el.rotation = (el.rotation + 45) % 360;
            }
          });
          saveState();
          redrawCanvas();
        }
        function deleteSelected() {
          if (selectedElements.length === 0) return;
          const selectedIds = new Set(selectedElements.map((el) => el.id));
          circuitElements = circuitElements.filter((el) => !selectedIds.has(el.id));
          selectedElements = [];
          saveState();
          redrawCanvas();
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            circuitElements.forEach((el) => drawElement(el));
            if (hoveredWireSegment) {
                ctx.save();
                ctx.strokeStyle = "#007bff";
                ctx.lineWidth = 4;
                ctx.shadowColor = "rgba(0, 123, 255, 0.7)";
                ctx.shadowBlur = 8;
                ctx.lineCap = "round";
                ctx.beginPath();
                ctx.moveTo(hoveredWireSegment.p1.x, hoveredWireSegment.p1.y);
                ctx.lineTo(hoveredWireSegment.p2.x, hoveredWireSegment.p2.y);
                ctx.stroke();
                ctx.restore();
            }
            drawJunctions();
            drawSelection();
            if (isDrawingWire && wireStartPoint) {
                let endPoint = getSnappingPoint(currentMousePos.x, currentMousePos.y);
                drawWirePreview(wireStartPoint, endPoint);
                drawSnapIndicator(endPoint);
            } else if (selectedTool === "wire" || selectedTool === "path-wire") {
                const snapPoint = getSnappingPoint(currentMousePos.x, currentMousePos.y);
                drawSnapIndicator(snapPoint);
            }
            if (isMarqueeSelecting && marqueeStartPoint) {
                drawMarquee(marqueeStartPoint, currentMousePos);
            }
            updateToolbar();
        }

        function resizeCanvas(newWidth, newHeight) {
          if (canvas.width >= newWidth && canvas.height >= newHeight) return;
          const finalWidth = Math.max(canvas.width, newWidth);
          const finalHeight = Math.max(canvas.height, newHeight);
          canvas.width = finalWidth;
          canvas.height = finalHeight;
          redrawCanvas();
        }

        function addBulkRow(name = "", qty = 1, label = "Y") {
          const row = document.createElement("tr");
          row.innerHTML = `<td><input type="text" class="comp-name" placeholder="e.g., R, C, SPDT" value="${name}"></td><td><input type="number" class="comp-qty" min="1" value="${qty}"></td><td><input type="text" class="comp-label" placeholder="Y or N" value="${label}" maxlength="1"></td><td><button class="delete-row-btn">&times;</button></td>`;
          bulkInputTableBody.appendChild(row);
        }

        function openBulkAddModal() { bulkInputTableBody.innerHTML = ""; addBulkRow(); bulkAddModal.style.display = "flex"; }
        function closeBulkAddModal() { bulkAddModal.style.display = "none"; }
        function openBulkTextModal() { bulkTextInput.value = ""; bulkTextModal.style.display = "flex"; }
        function closeBulkTextModal() { bulkTextModal.style.display = "none"; }

        function recalculateAutoLabelCounters() {
          autoLabelCounters = {};
          const labelRegex = /^([A-Z_a-z]+)(?:_\{)?(\d+)\}?$/i;
          circuitElements.forEach((el) => {
            if (el.type === "text" && el.text) {
              const match = el.text.match(labelRegex);
              if (match) {
                const prefix = match[1].toUpperCase();
                const num = parseInt(match[2], 10);
                if (!autoLabelCounters[prefix] || num >= autoLabelCounters[prefix]) {
                  autoLabelCounters[prefix] = num + 1;
                }
              }
            }
          });
        }

        function handleBulkPlace() {
            recalculateAutoLabelCounters();
            const rows = bulkInputTableBody.querySelectorAll("tr");
            const placeStepX = 150; const placeStepY = 120;
            const placementMargin = 100;
            const requests = [];
            let totalComponentCount = 0;

            for (const row of rows) {
                const nameInput = row.querySelector(".comp-name");
                const qtyInput = row.querySelector(".comp-qty");
                const labelInput = row.querySelector(".comp-label");
                const shortNameRaw = nameInput.value.trim();
                if (!shortNameRaw) continue;

                const shortName = shortNameRaw.toUpperCase();
                const quantity = parseInt(qtyInput.value, 10);
                const autoLabel = labelInput.value.trim().toUpperCase();
                const componentType = shortNameToTypeCI[shortName];

                if (!componentType) { alert(`Invalid component name: "${nameInput.value}".`); nameInput.focus(); return; }
                if (isNaN(quantity) || quantity < 1) { alert(`Invalid quantity: "${qtyInput.value}".`); qtyInput.focus(); return; }
                requests.push({ shortNameRaw, shortName, quantity, autoLabel, componentType });
                totalComponentCount += quantity;
            }

            if (totalComponentCount === 0) { closeBulkAddModal(); return; }

            const bounds = calculateBoundingBox();
            const placementStart = {
                x: placementMargin,
                y: bounds ? Math.floor((bounds.maxY + placementMargin) / gridSize) * gridSize : placementMargin,
            };

            const componentsPerRow = Math.max(1, Math.floor((canvas.width - placementMargin * 2) / placeStepX));
            const requiredRows = Math.ceil(totalComponentCount / componentsPerRow);
            const requiredWidth = placementStart.x + Math.min(totalComponentCount, componentsPerRow) * placeStepX;
            const requiredHeight = placementStart.y + requiredRows * placeStepY;
            resizeCanvas(requiredWidth, requiredHeight);

            let placeX = placementStart.x;
            let placeY = placementStart.y;
            const componentsToAdd = [];

            for (const req of requests) {
                for (let i = 0; i < req.quantity; i++) {
                    const newComp = { id: nextId++, type: req.componentType, x: placeX, y: placeY, rotation: 0, flipH: false, flipV: false };
                    if (newComp.type === "switch") newComp.state = "open";
                    if (newComp.type === "spdtSwitch") newComp.state = 1;
                    componentsToAdd.push(newComp);

                    if (req.autoLabel === "Y") {
                        if (!autoLabelCounters[req.shortName]) autoLabelCounters[req.shortName] = 1;
                        const labelText = req.shortName + "_{" + autoLabelCounters[req.shortName]++ + "}";
                        const newLabel = { id: nextId++, type: "text", text: labelText, x: placeX, y: placeY + 45, rotation: 0, isItalic: true };
                        componentsToAdd.push(newLabel);
                    }
                    placeX += placeStepX;
                    if (placeX > canvas.width - placementMargin) { placeX = placementStart.x; placeY += placeStepY; }
                }
            }
            if (componentsToAdd.length > 0) { circuitElements.push(...componentsToAdd); saveState(); redrawCanvas(); }
            closeBulkAddModal();
        }

        function handleBulkTextPlace() {
          const rawText = bulkTextInput.value.trim();
          if (!rawText) { closeBulkTextModal(); return; }

          if (rawText.startsWith("{") && rawText.endsWith("}")) {
            if (appendCircuitFromJSON(rawText, "Circuit appended successfully from text!")) {
              closeBulkTextModal();
            }
            return;
          }

          const textItems = rawText.split(";").map((item) => item.trim()).filter((item) => item.length > 0);
          if (textItems.length === 0) { closeBulkTextModal(); return; }

          const verticalSpacing = 40;
          const placementMargin = 100;
          const bounds = calculateBoundingBox();
          const placementStart = { x: placementMargin, y: bounds ? Math.floor((bounds.maxY + 80) / gridSize) * gridSize : 80 };
          const requiredHeight = placementStart.y + textItems.length * verticalSpacing;
          resizeCanvas(canvas.width, requiredHeight);

          let placeY = placementStart.y;
          const textsToAdd = [];
          textItems.forEach((item) => {
            const processedItem = evaluateExpressions(item);
            const newText = { id: nextId++, type: "text", text: processedItem, x: placementStart.x, y: placeY, rotation: 0, isItalic: true };
            textsToAdd.push(newText);
            placeY += verticalSpacing;
          });

          if (textsToAdd.length > 0) { circuitElements.push(...textsToAdd); saveState(); redrawCanvas(); }
          closeBulkTextModal();
        }

        function showTextInputModal(initialText = "", initialItalic = true) {
          return new Promise((resolve, reject) => {
            textInputArea.value = initialText;
            textItalicCheckbox.checked = initialItalic;
            textInputModal.style.display = "flex";
            textInputArea.focus();
            textInputArea.select();
            const onOk = () => { cleanup(); const processedText = evaluateExpressions(textInputArea.value); resolve({ text: processedText, isItalic: textItalicCheckbox.checked }); };
            const onCancel = () => { cleanup(); reject(); };
            const cleanup = () => { textModalOkBtn.removeEventListener("click", onOk); textModalCancelBtn.removeEventListener("click", onCancel); textInputModalClose.removeEventListener("click", onCancel); window.removeEventListener("keydown", onKeydown); textInputModal.style.display = "none"; };
            const onKeydown = (e) => { if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) { onOk(); } else if (e.key === "Escape") { onCancel(); } };
            textModalOkBtn.addEventListener("click", onOk, { once: true });
            textModalCancelBtn.addEventListener("click", onCancel, { once: true });
            textInputModalClose.addEventListener("click", onCancel, { once: true });
            window.addEventListener("keydown", onKeydown);
          });
        }

        function showTransformModal(element) {
            return new Promise((resolve, reject) => {
                transformRotationInput.value = element.rotation || 0;
                transformFlipHCheckbox.checked = element.flipH || false;
                transformFlipVCheckbox.checked = element.flipV || false;

                const currentDimensions = getDimensionsAndScale(element);
                transformWidthInput.value = currentDimensions.width;
                transformScaleCheckbox.checked = false;
                transformWidthInput.disabled = true;

                const onScaleChange = () => {
                    transformWidthInput.disabled = !transformScaleCheckbox.checked;
                };
                transformScaleCheckbox.addEventListener('change', onScaleChange);

                transformModal.style.display = "flex";
                transformRotationInput.focus();
                transformRotationInput.select();

                const onOk = () => {
                    const newRotation = parseFloat(transformRotationInput.value);
                    if (isNaN(newRotation)) { alert("Invalid angle."); return; }

                    const result = { rotation: newRotation, flipH: transformFlipHCheckbox.checked, flipV: transformFlipVCheckbox.checked };
                    
                    if (transformScaleCheckbox.checked) {
                        const newWidth = parseInt(transformWidthInput.value, 10);
                        if (isNaN(newWidth) || newWidth <= 0) { alert("Invalid width."); return; }
                        if (newWidth % 5 !== 0) { alert("Width must be a multiple of 5."); return; }

                        const defaultDims = componentData[element.type];
                        if (defaultDims && defaultDims.width > 0) {
                            const aspectRatio = defaultDims.height / defaultDims.width;
                            const newHeight = Math.round((newWidth * aspectRatio) / 5) * 5;
                            result.newWidth = newWidth;
                            result.newHeight = newHeight;
                        }
                    }
                    cleanup();
                    resolve(result);
                };

                const onCancel = () => { cleanup(); reject(); };
                const cleanup = () => {
                    transformScaleCheckbox.removeEventListener('change', onScaleChange);
                    transformModalOkBtn.removeEventListener("click", onOk);
                    transformModalCancelBtn.removeEventListener("click", onCancel);
                    transformModalClose.removeEventListener("click", onCancel);
                    window.removeEventListener("keydown", onKeydown);
                    transformModal.style.display = "none";
                };

                const onKeydown = (e) => { if (e.key === "Enter" && !e.ctrlKey && !e.metaKey) { e.preventDefault(); onOk(); } else if (e.key === "Escape") { onCancel(); } };
                transformModalOkBtn.addEventListener("click", onOk);
                transformModalCancelBtn.addEventListener("click", onCancel);
                transformModalClose.addEventListener("click", onCancel);
                window.addEventListener("keydown", onKeydown);
            });
        }

        function evaluateExpressions(text) {
          if (!text || !text.includes("&")) return text;
          const regex = /&(.+?)&/g;
          return text.replace(regex, (match, expression) => {
            try {
              const result = new Function("return " + expression)();
              if (typeof result !== "number" || !isFinite(result)) return match;
              if (Math.abs(result) > 1e6 || (Math.abs(result) < 1e-6 && result !== 0)) {
                return result.toExponential(6);
              }
              return parseFloat(result.toPrecision(6)).toString();
            } catch (e) { console.warn(`Could not evaluate expression: ${match}`, e.message); return match; }
          });
        }

        function drawElement(el, isSelected = false) {
          ctx.save();
          setDrawingStyle(isSelected, el.color);
          if (el.type === "wire") {
            drawWire(el, isSelected);
          } else if (el.type === "path-wire") {
            drawPathWire(el, isSelected);
          } else if (el.type === "text") {
            drawText(el, isSelected);
          } else {
            ctx.translate(el.x, el.y);
            ctx.scale(el.flipH ? -1 : 1, el.flipV ? -1 : 1);
            ctx.rotate((el.rotation * Math.PI) / 180);
            switch (el.type) {
              case "resistor": drawResistor(el); break;
              case "capacitor": drawCapacitor(el); break;
              case "inductor": drawInductor(el); break;
              case "diode": drawDiode(el); break;
              case "fwd": drawFWD(el); break;
              case "zener": drawZenerDiode(el); break;
              case "led": drawLED(el); break;
              case "switch": drawSwitch(el); break;
              case "spdtSwitch": drawSpdtSwitch(el); break;
              case "opamp": drawOPAMP(el); break;
              case "igbt": drawIGBT(el); break;
              case "nfet": drawNFET(el); break;
              case "pfet": drawPFET(el); break;
              case "npn": drawNPN(el); break;
              case "pnp": drawPNP(el); break;
              case "voltage": drawVoltageSource(el); break;
              case "acvoltage": drawACVoltageSource(el); break;
              case "currentsource": drawCurrentSource(el); break;
              case "dependent_voltage": drawDependentVoltageSource(el); break;
              case "dependent_current": drawDependentCurrentSource(el); break;
              case "battery": drawBattery(el); break;
              case "gnd": drawGround(el); break;
              case "arrow_marker": drawArrowMarker(el); break;
              case "junction": drawManualJunction(); break;
              case "open_terminal": drawOpenTerminal(); break;
            }
          }
          ctx.restore();
        }

        function setDrawingStyle(isSelected = false, color = "black") {
          const finalColor = color || "black";
          ctx.strokeStyle = isSelected ? "#007bff" : finalColor;
          ctx.fillStyle = isSelected ? "#007bff" : finalColor;
          ctx.lineWidth = isSelected ? 2.5 : 2;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
        }

        function handleMouseDown(e) {
            const mousePos = getMousePos(e);
            if (e.altKey) {
                e.preventDefault();
                const newArrow = { id: nextId++, type: "arrow_marker", x: snapToGrid(mousePos.x), y: snapToGrid(mousePos.y), rotation: 0, color: "black" };
                circuitElements.push(newArrow);
                saveState(); redrawCanvas(); return;
            }
            if (e.ctrlKey && !e.metaKey) {
                e.preventDefault();
                const newJunction = { id: nextId++, type: "junction", x: snapToGrid(mousePos.x), y: snapToGrid(mousePos.y), rotation: 0 };
                circuitElements.push(newJunction);
                saveState(); redrawCanvas(); return;
            }

            let needsStateSave = false;
            if (selectedTool === "select") {
                const clickedElement = getElementAtPos(mousePos.x, mousePos.y);
                if (clickedElement) {
                    isMarqueeSelecting = false; isDragging = true;
                    dragStartPoint = mousePos;
                    if (!selectedElements.some((el) => el.id === clickedElement.id)) { selectedElements = [clickedElement]; }
                    selectedElements.forEach((el) => {
                        const initialState = { x: el.x, y: el.y };
                        if (el.type === 'wire') {
                            initialState.start = { ...el.start };
                            initialState.end = { ...el.end };
                        } else if (el.type === 'path-wire') {
                            initialState.points = JSON.parse(JSON.stringify(el.points));
                        }
                        el.dragInitialState = initialState;
                    });
                } else {
                    isMarqueeSelecting = true; isDragging = false;
                    marqueeStartPoint = mousePos;
                    selectedElements = [];
                }
            } else if (selectedTool === "wire") {
                isDrawingWire = true;
                wireStartPoint = getSnappingPoint(mousePos.x, mousePos.y);
            } else if (selectedTool === "path-wire") {
                const startPoint = getSnappingPoint(mousePos.x, mousePos.y);
                const commandStr = prompt("Enter path commands (e.g., h 100 arrow box 60 40 h 100)", "h 100 v 80");
                if (commandStr) {
                    try {
                        const pathData = parsePathCommandString(startPoint, commandStr);
                        if (pathData && pathData.points.length > 1) {
                           circuitElements.push({ id: nextId++, type: "path-wire", commandStr: commandStr, ...pathData });
                           needsStateSave = true;
                        }
                    } catch (error) {
                       alert(`Error parsing path command: ${error.message}`);
                    }
                }
                selectedTool = "select";
            } else if (selectedTool === "text") {
                showTextInputModal("V_{out} = V_{in} \\frac{R_2}{R_1+R_2}", true)
                    .then(({ text, isItalic }) => {
                        if (text) {
                            const newEl = { id: nextId++, type: "text", text: text, x: snapToGrid(mousePos.x), y: snapToGrid(mousePos.y), rotation: 0, isItalic: isItalic };
                            circuitElements.push(newEl);
                            selectedTool = "select";
                            selectedElements = [newEl];
                            saveState(); redrawCanvas();
                        } else { selectedTool = "select"; redrawCanvas(); }
                    })
                    .catch(() => { selectedTool = "select"; redrawCanvas(); });
                return;
            } else {
                const newEl = { id: nextId++, type: selectedTool, x: snapToGrid(mousePos.x), y: snapToGrid(mousePos.y), rotation: 0, flipH: false, flipV: false };
                if (newEl.type === "switch") newEl.state = "open";
                if (newEl.type === "spdtSwitch") newEl.state = 1;
                circuitElements.push(newEl);
                selectedTool = "select";
                selectedElements = [newEl];
                needsStateSave = true;
            }
            if (needsStateSave) saveState();
            redrawCanvas();
        }

        function updateHoveredWireSegment() {
          if (selectedTool !== "wire") { hoveredWireSegment = null; return; }
          hoveredWireSegment = null;
          for (const wire of circuitElements) {
            if (wire.type !== "wire" && wire.type !== "path-wire") continue;
            const path = wire.type === 'wire' ? getWirePath(wire) : (wire.points || []);
            for (let i = 0; i < path.length - 1; i++) {
              const p1 = path[i];
              const p2 = path[i + 1];
              if (distToSegment(currentMousePos, p1, p2) < snapTolerance) {
                hoveredWireSegment = { p1, p2 };
                return;
              }
            }
          }
        }

        function handleMouseMove(e) {
          currentMousePos = getMousePos(e);
          if (isDragging && selectedElements.length > 0 && dragStartPoint) {
            const dx = currentMousePos.x - dragStartPoint.x, dy = currentMousePos.y - dragStartPoint.y;
            selectedElements.forEach((el) => {
              const initialState = el.dragInitialState;
              if (!initialState) return;
              if (el.type === "wire") {
                if (initialState.start && initialState.end) {
                  el.start.x = snapToGrid(initialState.start.x + dx); el.start.y = snapToGrid(initialState.start.y + dy);
                  el.end.x = snapToGrid(initialState.end.x + dx); el.end.y = snapToGrid(initialState.end.y + dy);
                }
              } else if (el.type === 'path-wire') {
                  if(initialState.points) {
                      el.points.forEach((p, i) => {
                          p.x = snapToGrid(initialState.points[i].x + dx);
                          p.y = snapToGrid(initialState.points[i].y + dy);
                      });
                  }
              } else {
                if (initialState.x !== undefined && initialState.y !== undefined) {
                  el.x = snapToGrid(initialState.x + dx); el.y = snapToGrid(initialState.y + dy);
                }
              }
            });
          }
          updateHoveredWireSegment();
          redrawCanvas();
        }

        function handleMouseUp(e) {
          let needsStateSave = false;
          if (isMarqueeSelecting) {
            const rect = {
              x1: Math.min(marqueeStartPoint.x, currentMousePos.x), y1: Math.min(marqueeStartPoint.y, currentMousePos.y),
              x2: Math.max(marqueeStartPoint.x, currentMousePos.x), y2: Math.max(marqueeStartPoint.y, currentMousePos.y),
            };
            selectedElements = circuitElements.filter((el) => isElementInRect(el, rect));
          }
          if (isDrawingWire) {
            const endPoint = getSnappingPoint(currentMousePos.x, currentMousePos.y);
            if (Math.hypot(endPoint.x - wireStartPoint.x, endPoint.y - wireStartPoint.y) > 0) {
              circuitElements.push({ id: nextId++, type: "wire", start: wireStartPoint, end: endPoint, routing: isShiftDown ? "direct" : "manhattan" });
              needsStateSave = true;
            }
          }
          if (isDragging) { needsStateSave = true; }
          isDrawingWire = false; isDragging = false; isMarqueeSelecting = false;
          marqueeStartPoint = null; dragStartPoint = null;
          circuitElements.forEach((el) => delete el.dragInitialState);
          if (needsStateSave) saveState();
          redrawCanvas();
        }

        function handleDoubleClick(e) {
            e.preventDefault();
            const mousePos = getMousePos(e);
            const clickedElement = getElementAtPos(mousePos.x, mousePos.y);

            if (!clickedElement) {
                const newTerminal = { id: nextId++, type: "open_terminal", x: snapToGrid(mousePos.x), y: snapToGrid(mousePos.y), rotation: 0 };
                circuitElements.push(newTerminal);
                saveState(); redrawCanvas(); return;
            }
 
            if (clickedElement.type === "path-wire") {
                const oldCommandStr = clickedElement.commandStr || "";
                const newCommandStr = prompt("Edit path commands (e.g., h 100 arrow box 60 40):", oldCommandStr);

                if (newCommandStr === null) {
                    return; // User cancelled
                }

                try {
                    const startPoint = clickedElement.points[0];
                    if (!startPoint) throw new Error("Path is invalid and has no starting point.");
                    
                    const newPathData = parsePathCommandString(startPoint, newCommandStr);
                    
                    if (newPathData && newPathData.points.length > 1) {
                        // Update the existing element with new data
                        clickedElement.points = newPathData.points;
                        clickedElement.corners = newPathData.corners;
                        clickedElement.shapes = newPathData.shapes;
                        clickedElement.arrows = newPathData.arrows;
                        clickedElement.commandStr = newCommandStr;
                        delete clickedElement.hasArrow; // remove obsolete property

                        saveState();
                        redrawCanvas();
                    } else {
                       alert("The command did not produce a valid path. No changes were made.");
                    }
                } catch (error) {
                    alert(`Error parsing path command: ${error.message}`);
                }
                return; // Stop further processing for this element
            }

            if (clickedElement.type === "switch") { clickedElement.state = clickedElement.state === "closed" ? "open" : "closed"; saveState(); redrawCanvas(); return; }
            if (clickedElement.type === "spdtSwitch") { clickedElement.state = clickedElement.state === 1 ? 2 : 1; saveState(); redrawCanvas(); return; }

            if (clickedElement.type === "text") {
                showTextInputModal(clickedElement.text, clickedElement.isItalic ?? true)
                    .then(({ text, isItalic }) => {
                        clickedElement.text = evaluateExpressions(text);
                        clickedElement.isItalic = isItalic;
                        saveState(); redrawCanvas();
                    }).catch(() => {});
                return;
            }
            
            const isTransformableComponent = clickedElement.type !== "wire" && clickedElement.type !== "path-wire" && clickedElement.type !== "junction" && clickedElement.type !== "open_terminal";

            if (isTransformableComponent) {
                showTransformModal(clickedElement)
                    .then(transformData => {
                        clickedElement.rotation = transformData.rotation;
                        clickedElement.flipH = transformData.flipH;
                        clickedElement.flipV = transformData.flipV;
                        if (transformData.newWidth !== undefined) {
                            clickedElement.width = transformData.newWidth;
                            clickedElement.height = transformData.newHeight;
                        }
                        saveState(); redrawCanvas();
                    }).catch(() => {});
                return;
            }
        }

        canvas.addEventListener("mousedown", handleMouseDown);
        canvas.addEventListener("mousemove", handleMouseMove);
        canvas.addEventListener("mouseup", handleMouseUp);
        canvas.addEventListener("dblclick", handleDoubleClick);
        canvas.addEventListener("mouseout", () => { isDrawingWire = false; isDragging = false; isMarqueeSelecting = false; marqueeStartPoint = null; isShiftDown = false; hoveredWireSegment = null; redrawCanvas(); });

        function getMousePos(e) { return { x: e.clientX - canvas.getBoundingClientRect().left, y: e.clientY - canvas.getBoundingClientRect().top }; }
        function snapToGrid(val) { return Math.round(val / (gridSize / 4)) * (gridSize / 4); }

        function getWireSegmentSnapPoint(pos) {
          for (const wire of circuitElements) {
            if (wire.type !== "wire" && wire.type !== "path-wire") continue;
            const path = wire.type === 'wire' ? getWirePath(wire) : (wire.points || []);
            for (let i = 0; i < path.length - 1; i++) {
              const p1 = path[i];
              const p2 = path[i + 1];
              if (distToSegment(pos, p1, p2) < snapTolerance) {
                const projectedPoint = projectPointOnSegment(pos, p1, p2);
                const snappedX = Math.round(projectedPoint.x / fineGridSize) * fineGridSize;
                const snappedY = Math.round(projectedPoint.y / fineGridSize) * fineGridSize;
                return { x: snappedX, y: snappedY };
              }
            }
          }
          return null;
        }

        function getSnappingPoint(x, y) {
          if (selectedTool === "wire" || selectedTool === "path-wire") {
            const segmentSnap = getWireSegmentSnapPoint({ x, y });
            if (segmentSnap) return segmentSnap;
          }
          for (const el of circuitElements) {
            if (el.type === "wire" || el.type === "path-wire" || el.type === "text" || el.type === "junction" || el.type === "open_terminal") continue;
            const terminals = getAbsoluteTerminals(el);
            for (const term of terminals) {
              if (Math.hypot(x - term.x, y - term.y) < snapTolerance) return { x: term.x, y: term.y, ownerId: el.id };
            }
          }
          for (const el of circuitElements) {
            if (el.type === "junction" || el.type === "open_terminal") {
              if (Math.hypot(x - el.x, y - el.y) < snapTolerance) return { x: el.x, y: el.y, ownerId: el.id };
            }
          }
          for (const el of circuitElements) {
            if (el.type === "wire") {
              if (Math.hypot(x - el.start.x, y - el.start.y) < snapTolerance) return { x: el.start.x, y: el.start.y };
              if (Math.hypot(x - el.end.x, y - el.end.y) < snapTolerance) return { x: el.end.x, y: el.end.y };
            } else if (el.type === "path-wire" && el.points && el.points.length > 0) {
              const start = el.points[0];
              const end = el.points[el.points.length - 1];
              if (Math.hypot(x - start.x, y - start.y) < snapTolerance) return { ...start };
              if (Math.hypot(x - end.x, y - end.y) < snapTolerance) return { ...end };
            }
          }
          return { x: snapToGrid(x), y: snapToGrid(y), ownerId: null };
        }

        function getAbsoluteTerminals(el) {
            const defaultData = componentData[el.type];
            if (!defaultData || !defaultData.terminals) return [];

            const { scale } = getDimensionsAndScale(el);
            
            const flipScaleX = el.flipH ? -1 : 1;
            const flipScaleY = el.flipV ? -1 : 1;
            const angle = (el.rotation * Math.PI) / 180;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            
            return defaultData.terminals.map(t => {
                const scaledTermX = t.x * scale;
                const scaledTermY = t.y * scale;
                const flippedX = scaledTermX * flipScaleX;
                const flippedY = scaledTermY * flipScaleY;
                const rotatedX = flippedX * cos - flippedY * sin;
                const rotatedY = flippedX * sin + flippedY * cos;
                return { x: el.x + rotatedX, y: el.y + rotatedY };
            });
        }

        function getElementAtPos(x, y) {
          for (let i = circuitElements.length - 1; i >= 0; i--) {
            const el = circuitElements[i];
            if (el.type === "junction" || el.type === "open_terminal") {
              if (Math.hypot(x - el.x, y - el.y) < snapTolerance) return el;
            }
          }
          for (let i = circuitElements.length - 1; i >= 0; i--) {
            const el = circuitElements[i];
            if (el.type === "wire" || el.type === "path-wire" || el.type === "junction" || el.type === "open_terminal") continue;
            if (el.type === "text") {
              const { width, height } = measureParsedText(el);
              const padding = 4;
              if (x > el.x - width / 2 - padding && x < el.x + width / 2 + padding && y > el.y - height / 2 - padding && y < el.y + height / 2 + padding) {
                return el;
              }
            } else {
              const { width, height } = getDimensionsAndScale(el);
              const dx = x - el.x;
              const dy = y - el.y;
              const angle = (-el.rotation * Math.PI) / 180;
              const rX = dx * Math.cos(angle) - dy * Math.sin(angle);
              const rY = dx * Math.sin(angle) + dy * Math.cos(angle);
              const scaleX = el.flipH ? -1 : 1;
              const scaleY = el.flipV ? -1 : 1;
              const localX = rX * scaleX;
              const localY = rY * scaleY;
              if (Math.abs(localX) < width / 2 && Math.abs(localY) < height / 2) return el;
            }
          }
          for (let i = circuitElements.length - 1; i >= 0; i--) {
            const el = circuitElements[i];
            if (el.type === 'wire' || el.type === 'path-wire') {
               if (isPointOnWire({ x, y }, el)) return el;
            }
          }
          return null;
        }

        function distToSegment(p, v, w) {
          const l2 = (v.x - w.x) ** 2 + (v.y - w.y) ** 2;
          if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
          let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
          t = Math.max(0, Math.min(1, t));
          return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
        }

        function projectPointOnSegment(p, v, w) {
          const l2 = (v.x - w.x) ** 2 + (v.y - w.y) ** 2;
          if (l2 === 0) return { x: v.x, y: v.y };
          let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
          t = Math.max(0, Math.min(1, t));
          return { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) };
        }

        function isPointOnWire(point, wire) {
            const path = wire.type === 'wire' ? getWirePath(wire) : (wire.points || []);
            for (let i = 0; i < path.length - 1; i++) {
                if (distToSegment(point, path[i], path[i + 1]) < snapTolerance) return true;
            }
            return false;
        }

        function isElementInRect(el, rect) {
          if (el.type === "wire") {
             return (el.start.x >= rect.x1 && el.start.x <= rect.x2 && el.start.y >= rect.y1 && el.start.y <= rect.y2) &&
                    (el.end.x >= rect.x1 && el.end.x <= rect.x2 && el.end.y >= rect.y1 && el.end.y <= rect.y2);
          }
          if (el.type === "path-wire" && el.points) {
              return el.points.every(p => p.x >= rect.x1 && p.x <= rect.x2 && p.y >= rect.y1 && p.y <= rect.y2);
          }
          return (el.x >= rect.x1 && el.x <= rect.x2 && el.y >= rect.y1 && el.y <= rect.y2);
        }

        function drawGrid() {
            ctx.strokeStyle = "#e9ecef"; ctx.lineWidth = 1; ctx.beginPath();
            for (let x = 0; x <= canvas.width; x += gridSize) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); }
            for (let y = 0; y <= canvas.height; y += gridSize) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); }
            ctx.stroke();
        }

        function drawSelection() {
          if (selectedElements.length === 0) return;
          selectedElements.forEach((el) => {
            ctx.save();
            ctx.strokeStyle = "#007bff"; ctx.lineWidth = 1; ctx.setLineDash([4, 2]);
            if (el.type === "wire") {
              drawWire(el, true);
            } else if (el.type === "path-wire") {
                drawPathWire(el, true);
            } else if (el.type === "text") {
              const { width, height } = measureParsedText(el);
              const padding = 4;
              ctx.strokeRect(el.x - width / 2 - padding, el.y - height / 2 - padding, width + padding * 2, height + padding * 2);
            } else if (el.type === "junction" || el.type === "open_terminal") {
              ctx.translate(el.x, el.y); ctx.beginPath(); ctx.arc(0, 0, 8, 0, 2 * Math.PI); ctx.stroke();
            } else {
              const { width, height } = getDimensionsAndScale(el);
              ctx.translate(el.x, el.y);
              ctx.scale(el.flipH ? -1 : 1, el.flipV ? -1 : 1);
              ctx.rotate((el.rotation * Math.PI) / 180);
              ctx.strokeRect(-width / 2, -height / 2, width, height);
            }
            ctx.restore();
          });
        }

        function drawMarquee(start, end) {
            ctx.save();
            ctx.fillStyle = "rgba(0, 123, 255, 0.1)"; ctx.strokeStyle = "rgba(0, 123, 255, 0.5)";
            ctx.lineWidth = 1; ctx.setLineDash([6, 3]);
            const width = end.x - start.x, height = end.y - start.y;
            ctx.beginPath(); ctx.rect(start.x, start.y, width, height); ctx.fill(); ctx.stroke();
            ctx.restore();
        }
        function drawSnapIndicator(point) {
            ctx.beginPath(); ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI); ctx.fillStyle = "rgba(255, 0, 0, 0.5)"; ctx.fill();
        }
        function getWirePath(wire) { return wire.routing === "direct" ? [wire.start, wire.end] : [wire.start, { x: wire.start.x, y: wire.end.y }, wire.end]; }
        function drawWireFromPath(path) {
            ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) { ctx.lineTo(path[i].x, path[i].y); }
            ctx.stroke();
        }
        function drawWire(el, isSelected) { setDrawingStyle(isSelected, el.color); drawWireFromPath(getWirePath(el)); }
        function drawWirePreview(start, end) {
            ctx.save(); setDrawingStyle(true); ctx.setLineDash([4, 4]);
            drawWireFromPath(getWirePath({ start, end, routing: isShiftDown ? "direct" : "manhattan" }));
            ctx.restore();
        }

        function drawJunctions() {
            const connectionPoints = new Map();
            const addPoint = (p) => { const key = `${p.x},${p.y}`; connectionPoints.set(key, (connectionPoints.get(key) || 0) + 1); };
            circuitElements.forEach((el) => {
                if (el.type === "wire") { addPoint(el.start); addPoint(el.end); } 
                else if (el.type === "path-wire" && el.points) { el.points.forEach(p => addPoint(p)); }
                else if (el.type === "junction" || el.type === "open_terminal") { addPoint(el); } 
                else if (el.type !== "text") { getAbsoluteTerminals(el).forEach((term) => addPoint(term)); }
            });
            ctx.save(); ctx.fillStyle = "#000";
            for (const [key, count] of connectionPoints.entries()) {
                if (count > 2) {
                    const [x, y] = key.split(",").map(Number);
                    ctx.beginPath(); ctx.arc(x, y, 4, 0, 2 * Math.PI); ctx.fill();
                }
            }
            ctx.restore();
        }

        const greekSymbolMap = {
          alpha: "", beta: "", gamma: "", Delta: "", delta: "", epsilon: "", eta: "", theta: "", lambda: "", Lambda:"", mu: "", nu:"",xi:"",
          pi: "", rho: "", Sigma: "", sigma: "", tau: "", Phi: "", phi: "", Omega: "", omega: "", times: "", zeta: "",chi:"", Psi:"", psi:""
        };

        function findMatchingBrace(text, startIndex) {
          let braceLevel = 1;
          for (let i = startIndex; i < text.length; i++) {
            if (text[i] === "{") braceLevel++;
            else if (text[i] === "}") { braceLevel--; if (braceLevel === 0) return i; }
          }
          return -1;
        }

        function _parseInternal(text) {
          const chunks = []; let currentText = "";
          for (let i = 0; i < text.length; i++) {
            const char = text[i]; let specialHandled = false;
            if (char === "_" || char === "^") {
              if (currentText) { chunks.push({ type: "normal", text: currentText }); currentText = ""; }
              const type = char === "_" ? "subscript" : "superscript";
              let content = ""; let jump = 0;
              if (text[i + 1] === "{") {
                const endBrace = findMatchingBrace(text, i + 2);
                if (endBrace !== -1) { content = text.substring(i + 2, endBrace); jump = endBrace - i; }
              } else if (i + 1 < text.length) { content = text[i + 1]; jump = 1; }
              if (content) { chunks.push({ type: type, content: _parseInternal(content) }); i += jump; } 
              else { currentText += char; }
              specialHandled = true;
            } else if (char === "\\") {
              if (currentText) { chunks.push({ type: "normal", text: currentText }); currentText = ""; }
              if (text.substring(i, i + 5) === "\\frac" && text[i + 5] === "{") {
                const numEnd = findMatchingBrace(text, i + 6);
                if (numEnd !== -1 && text[numEnd + 1] === "{") {
                  const denEnd = findMatchingBrace(text, numEnd + 2);
                  if (denEnd !== -1) {
                    const numerator = text.substring(i + 6, numEnd);
                    const denominator = text.substring(numEnd + 2, denEnd);
                    chunks.push({ type: "fraction", numerator: _parseInternal(numerator), denominator: _parseInternal(denominator) });
                    i = denEnd; specialHandled = true;
                  }
                }
              } else {
                let symbolCandidate = ""; let bestMatch = "";
                for (let j = i + 1; j < text.length; j++) {
                  if (!text[j].match(/[a-zA-Z]/)) break;
                  symbolCandidate += text[j];
                  if (greekSymbolMap.hasOwnProperty(symbolCandidate)) { bestMatch = symbolCandidate; }
                }
                if (bestMatch) { chunks.push({ type: "normal", text: greekSymbolMap[bestMatch] }); i += bestMatch.length; specialHandled = true; }
              }
            }
            if (!specialHandled) { currentText += char; }
          }
          if (currentText) chunks.push({ type: "normal", text: currentText });
          return chunks;
        }

        function parseText(rawText) { if (!rawText) return []; return _parseInternal(rawText); }

        function measureRecursive(chunks, currentFontSize, isItalic) {
            let totalWidth = 0; let maxAscent = 0; let maxDescent = 0;
            const subSuperScale = 0.85; const fractionLinePadding = 4;
            const fontStyle = isItalic ? "italic" : "normal";
            ctx.font = `${fontStyle} ${currentFontSize}px Georgia`;
            const baselineHeight = ctx.measureText("M").width * 0.8;

            chunks.forEach((chunk) => {
                if (chunk.type === "normal") {
                    ctx.font = `${fontStyle} ${currentFontSize}px Georgia`;
                    const metrics = ctx.measureText(chunk.text);
                    totalWidth += metrics.width;
                    maxAscent = Math.max(maxAscent, baselineHeight);
                    maxDescent = Math.max(maxDescent, 0);
                } else if (chunk.type === "subscript" || chunk.type === "superscript") {
                    const subMetrics = measureRecursive(chunk.content, currentFontSize * subSuperScale, isItalic);
                    totalWidth += subMetrics.width;
                    if (chunk.type === "superscript") { maxAscent = Math.max(maxAscent, subMetrics.height + baselineHeight * 0.4); } 
                    else { maxDescent = Math.max(maxDescent, subMetrics.height - baselineHeight * 0.4); }
                } else if (chunk.type === "fraction") {
                    const numMetrics = measureRecursive(chunk.numerator, currentFontSize, isItalic);
                    const denMetrics = measureRecursive(chunk.denominator, currentFontSize, isItalic);
                    const fracWidth = Math.max(numMetrics.width, denMetrics.width) + 4;
                    totalWidth += fracWidth;
                    const fractionAscent = numMetrics.height + fractionLinePadding;
                    const fractionDescent = denMetrics.height + fractionLinePadding;
                    maxAscent = Math.max(maxAscent, fractionAscent);
                    maxDescent = Math.max(maxDescent, fractionDescent);
                }
            });
            return { width: totalWidth, height: maxAscent + maxDescent, ascent: maxAscent, descent: maxDescent };
        }

        function measureParsedText(el) {
          if (!el.text) return { width: 0, height: textFontSize };
          const isItalic = el.isItalic ?? true;
          const chunks = parseText(el.text);
          const metrics = measureRecursive(chunks, textFontSize, isItalic);
          return { width: metrics.width, height: Math.max(textFontSize, metrics.height) };
        }

        function drawRecursive(chunks, x, y, currentFontSize, isItalic) {
            let currentX = x;
            const subSuperScale = 0.85; const subSuperYOffsetFactor = 0.4;
            const fractionLinePadding = 4; const fontStyle = isItalic ? "italic" : "normal";
            ctx.font = `${fontStyle} ${currentFontSize}px Georgia`;

            chunks.forEach((chunk) => {
                if (chunk.type === "normal") {
                    ctx.font = `${fontStyle} ${currentFontSize}px Georgia`;
                    ctx.fillText(chunk.text, currentX, y);
                    currentX += ctx.measureText(chunk.text).width;
                } else if (chunk.type === "subscript" || chunk.type === "superscript") {
                    const newFontSize = currentFontSize * subSuperScale;
                    const yOffset = (chunk.type === "subscript" ? 1 : -1) * currentFontSize * subSuperYOffsetFactor;
                    currentX = drawRecursive(chunk.content, currentX, y + yOffset, newFontSize, isItalic);
                } else if (chunk.type === "fraction") {
                    const numMetrics = measureRecursive(chunk.numerator, currentFontSize, isItalic);
                    const denMetrics = measureRecursive(chunk.denominator, currentFontSize, isItalic);
                    const fracWidth = Math.max(numMetrics.width, denMetrics.width);
                    const numX = currentX + (fracWidth - numMetrics.width) / 2;
                    const denX = currentX + (fracWidth - denMetrics.width) / 2;
                    const dividerY = y + 2;
                    const numY = dividerY - numMetrics.descent - fractionLinePadding;
                    const denY = dividerY + denMetrics.ascent + fractionLinePadding;
                    drawRecursive(chunk.numerator, numX, numY, currentFontSize, isItalic);
                    drawRecursive(chunk.denominator, denX, denY, currentFontSize, isItalic);
                    ctx.beginPath(); ctx.moveTo(currentX - 2, dividerY + 4); ctx.lineTo(currentX + fracWidth + 2, dividerY + 4); ctx.stroke();
                    currentX += fracWidth + 4;
                }
            });
            return currentX;
        }

        function drawText(el, isSelected) {
          const baseColor = el.color === "red" ? "red" : "black";
          ctx.fillStyle = isSelected ? "#007bff" : baseColor;
          ctx.strokeStyle = ctx.fillStyle; ctx.textBaseline = "middle"; ctx.textAlign = "left";
          const isItalic = el.isItalic ?? true;
          const chunks = parseText(el.text);
          const { width: totalWidth, ascent, descent } = measureRecursive(chunks, textFontSize, isItalic);
          const totalHeight = ascent + descent;
          const startY = el.y - totalHeight / 2 + ascent;
          const startX = el.x - totalWidth / 2;
          drawRecursive(chunks, startX, startY, textFontSize, isItalic);
        }

        function drawManualJunction() { ctx.beginPath(); ctx.arc(0, 0, 4, 0, 2 * Math.PI); ctx.fillStyle = ctx.strokeStyle; ctx.fill(); }
        function drawOpenTerminal() { ctx.beginPath(); ctx.arc(0, 0, 4, 0, 2 * Math.PI); ctx.fillStyle = "#fff"; ctx.fill(); ctx.strokeStyle = "#000"; ctx.stroke(); }
        
        // --- START: NEW/MODIFIED PATH WIRE FUNCTIONS ---
        function parsePathCommandString(startPoint, commandStr) {
            const points = [startPoint];
            const corners = {};
            const shapes = {};
            const arrows = [];

            let currentPos = { ...startPoint };
            let lastDirection = 'h'; // Keep track of the last line direction
            const tokens = commandStr.trim().toLowerCase().split(/\s+/).filter(Boolean);

            for (let i = 0; i < tokens.length; i++) {
                const token = tokens[i];
                let val1, val2;

                const peek = (offset = 1) => (i + offset < tokens.length) ? tokens[i + offset] : null;
                const isNumeric = (str) => str !== null && !isNaN(parseFloat(str));
                
                switch (token) {
                    case 'h':
                        if (isNumeric(peek())) {
                            val1 = parseFloat(tokens[++i]);
                            currentPos.x += val1;
                            points.push({ ...currentPos });
                        }
                        lastDirection = 'h';
                        break;
                    case 'v':
                        if (isNumeric(peek())) {
                            val1 = parseFloat(tokens[++i]);
                            currentPos.y += val1;
                            points.push({ ...currentPos });
                        }
                        lastDirection = 'v';
                        break;
                    case 'box':
                        if (isNumeric(peek(1)) && isNumeric(peek(2))) {
                            val1 = parseFloat(tokens[++i]); // width
                            val2 = parseFloat(tokens[++i]); // height
                            const segIdx = points.length - 1;
                            shapes[segIdx] = { type: 'box', w: val1, h: val2, direction: lastDirection };
                            if (lastDirection === 'h') { currentPos.x += val1; } 
                            else { currentPos.y += val2; }
                            points.push({ ...currentPos });
                        }
                        break;
                    case 'triangle':
                        if (isNumeric(peek(1)) && isNumeric(peek(2))) {
                            val1 = parseFloat(tokens[++i]); // base
                            val2 = parseFloat(tokens[++i]); // height
                            const segIdx = points.length - 1;
                            shapes[segIdx] = { type: 'triangle', base: val1, h: val2, direction: lastDirection };
                            if (lastDirection === 'h') { currentPos.x += val1; }
                            else { currentPos.y += val2; }
                            points.push({ ...currentPos });
                        }
                        break;
                    case 'circle':
                        if (isNumeric(peek())) {
                            val1 = parseFloat(tokens[++i]); // radius
                            const segIdx = points.length - 1;
                            shapes[segIdx] = { type: 'circle', r: val1, direction: lastDirection };
                            if (lastDirection === 'h') { currentPos.x += 2 * val1; }
                            else { currentPos.y += 2 * val1; }
                            points.push({ ...currentPos });
                        }
                        break;
                    case 'arrow':
                        if (points.length > 1) {
                            arrows.push(points.length - 2);
                        }
                        break;
                    case 'cr': // Fillet corner
                        if (isNumeric(peek()) && points.length > 1) {
                            val1 = parseFloat(tokens[++i]);
                            corners[points.length - 1] = val1;
                        }
                        break;
                    default:
                         // Silently ignore unknown commands
                        break;
                }
            }
            return { points, corners, shapes, arrows };
        }

        function drawPathWire(el, isSelected) {
            setDrawingStyle(isSelected, el.color);
            const { points, corners, shapes, arrows } = el;
            if (!points || points.length < 2) return;

            // --- 1. Draw all line segments (respecting fillets and interruptions from shapes) ---
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                if (shapes?.[i - 1]) { // If the segment leading to this point was a shape
                    ctx.moveTo(points[i].x, points[i].y);
                    continue;
                }

                const p_corner = points[i];
                const p_next = (i + 1 < points.length) ? points[i + 1] : null;
                const radius = corners?.[i];

                if (radius && p_next && !shapes?.[i]) { // Fillet at this corner
                    ctx.arcTo(p_corner.x, p_corner.y, p_next.x, p_next.y, radius);
                } else {
                    ctx.lineTo(p_corner.x, p_corner.y);
                }
            }
            ctx.stroke();

            // --- 2. Draw the shapes ---
            if (shapes) {
                for (const segIdxStr in shapes) {
                    const segIdx = parseInt(segIdxStr, 10);
                    const shapeInfo = shapes[segIdx];
                    const p_start = points[segIdx];
                    const p_end = points[segIdx + 1];

                    const isVertical = shapeInfo.direction === 'v';

                    switch(shapeInfo.type) {
                        case 'box':
                            if (isVertical) {
                                // Draw vertical box, advancing along Y
                                ctx.strokeRect(p_start.x - shapeInfo.w / 2, p_start.y, shapeInfo.w, shapeInfo.h);
                            } else {
                                // Draw horizontal box (original)
                                ctx.strokeRect(p_start.x, p_start.y - shapeInfo.h / 2, shapeInfo.w, shapeInfo.h);
                            }
                            break;
                        case 'triangle':
                            ctx.beginPath();
                            if (isVertical) {
                                // Draw vertical triangle (pointing down)
                                ctx.moveTo(p_start.x - shapeInfo.base / 2, p_start.y); // Top-left corner
                                ctx.lineTo(p_start.x + shapeInfo.base / 2, p_start.y); // Top-right corner
                                ctx.lineTo(p_end.x, p_end.y);                         // Bottom tip
                            } else {
                                // Draw horizontal triangle (original, pointing right)
                                ctx.moveTo(p_start.x, p_start.y + shapeInfo.h / 2); // Bottom-left corner
                                ctx.lineTo(p_start.x, p_start.y - shapeInfo.h / 2); // Top-left corner
                                ctx.lineTo(p_end.x, p_end.y);                         // Right tip
                            }
                            ctx.closePath();
                            ctx.stroke();
                            break;
                        case 'circle':
                            let centerX, centerY;
                            if (isVertical) {
                                centerX = p_start.x;
                                centerY = p_start.y + shapeInfo.r;
                            } else {
                                centerX = p_start.x + shapeInfo.r;
                                centerY = p_start.y;
                            }
                            ctx.beginPath();
                            ctx.arc(centerX, centerY, shapeInfo.r, 0, 2 * Math.PI);
                            ctx.stroke();
                            break;
                    }
                }
            }
            
            // --- 3. Draw the arrows ---
            if (arrows) {
                arrows.forEach(segIdx => {
                    if (segIdx < points.length - 1) {
                        const p_from = points[segIdx];
                        const p_to = points[segIdx + 1];
                        // Draw the arrowhead so its tip lands exactly at the destination point.
                        const dx = p_to.x - p_from.x;
                        const dy = p_to.y - p_from.y;
                        const len = Math.hypot(dx, dy);
                        if (len > 0) {
    const extended_x = p_to.x + (dx/len)*1.5 ; // This line pushes the tip forward
    const extended_y = p_to.y + (dy/len) *1.5; // This line pushes the tip forward
    drawArrowhead(ctx, p_from.x, p_from.y, extended_x, extended_y);
}
                    }
                });
            }
        }
        // --- END: NEW/MODIFIED PATH WIRE FUNCTIONS ---
        
        // --- START: SCALE-AWARE DRAWING FUNCTIONS ---
        function drawResistor(el) {
            const { scale } = getDimensionsAndScale(el);
            const w = 18 * scale, h = 9 * scale, len = 40 * scale;
            ctx.beginPath();
            ctx.moveTo(-len, 0); ctx.lineTo(-w, 0);
            for (let i = 0; i < 6; i++) {
                ctx.lineTo(-w + (i * 2 + 1) * (w / 6), i % 2 === 0 ? -h : h);
            }
            ctx.lineTo(w, 0); ctx.lineTo(len, 0);
            ctx.stroke();
        }

        function drawCapacitor(el) {
            const { scale } = getDimensionsAndScale(el);
            const plateDist = 10 * scale, plateLen = 28 * scale, leadLen = 40 * scale;
            ctx.beginPath(); ctx.moveTo(-leadLen, 0); ctx.lineTo(-plateDist / 2, 0);
            ctx.moveTo(-plateDist / 2, -plateLen / 2); ctx.lineTo(-plateDist / 2, plateLen / 2);
            ctx.moveTo(plateDist / 2, -plateLen / 2); ctx.lineTo(plateDist / 2, plateLen / 2);
            ctx.moveTo(plateDist / 2, 0); ctx.lineTo(leadLen, 0); ctx.stroke();
        }
        
        function drawInductor() {
          // 1. READ the desired final line width from the context.
          //    This will be '2' after setDrawingStyle(false) is called.
          const baseLineWidth = ctx.lineWidth;

          const originalCenterX = 218;
          const originalCenterY = 457;
          const originalWidth = 37.78;
          const targetWidth = 42;
          const scaleFactor = targetWidth / originalWidth;
          const angle = (-45 * Math.PI) / 180;

          // --- Draw the Transformed Inductor Coils ---
          ctx.save();

          // 2. COMPENSATE the line width for the upcoming scaling.
          //    This ensures the coils are drawn with a final visual thickness of 'baseLineWidth'.
          ctx.lineWidth = baseLineWidth / scaleFactor;

          // Apply transformations for the coils
          ctx.rotate(angle);
          ctx.scale(scaleFactor, scaleFactor);
          ctx.translate(-originalCenterX, -originalCenterY);

          // Define and draw the coil paths
          const pathData = [
            "m 219.95536,449.39345 c -1.70702,-1.35573 -4.87183,-1.13729 -7.47037,0.0774 -2.93691,1.3729 -6.23449,5.09529 -5.27517,6.50738",
            "m 219.95536,449.39345 c 1.35573,1.70702 1.13729,4.87183 -0.0774,7.47037 -1.3729,2.93691 -5.09529,6.23449 -6.50738,5.27517",
            "m 213.7946,443.23269 c 1.35573,1.70702 1.13729,4.87183 -0.0774,7.47037 -1.3729,2.93691 -5.09529,6.23449 -6.50738,5.27517",
            "m 226.11612,455.55421 c -1.70702,-1.35573 -4.87183,-1.13729 -7.47037,0.0774 -2.93691,1.3729 -6.23449,5.09529 -5.27517,6.50738",
            "m 226.11612,455.55421 c 1.35573,1.70702 1.13729,4.87183 -0.0774,7.47037 -1.3729,2.93691 -5.09529,6.23449 -6.50738,5.27517",
            "m 232.27688,461.71497 c -1.70702,-1.35573 -4.87183,-1.13729 -7.47037,0.0774 -2.93691,1.3729 -6.23449,5.09529 -5.27517,6.50738",
            "m 232.27688,461.71497 c 1.63452,1.48399 0.9202,6.50391 -1.11912,9.36441",
            "m 213.7946,443.23269 c -1.48399,-1.63452 -6.50391,-0.9202 -9.36441,1.11912",
          ];
          const paths = pathData.map((d) => new Path2D(d));
          paths.forEach((path) => ctx.stroke(path));
          ctx.restore();

          // --- Draw the Connecting Lines ---
          // These lines are not scaled, so we can use the baseLineWidth directly.
          ctx.beginPath();
          ctx.moveTo(-40, 0);
          ctx.lineTo(-21, 0);
          ctx.moveTo(21, 0);
          ctx.lineTo(40, 0);
          // The line width is already set to 2 by setDrawingStyle, so we just stroke.
          ctx.stroke();
        }

        function drawDiode(el) {
            const { scale } = getDimensionsAndScale(el);
            const triHeight = 22 * scale, baseX = -10 * scale, tipX = 10 * scale, leadLen = 30 * scale;
            ctx.beginPath(); ctx.lineJoin = "round"; ctx.moveTo(-leadLen, 0); ctx.lineTo(baseX, 0); ctx.moveTo(tipX, 0); ctx.lineTo(leadLen, 0); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(baseX, -triHeight / 2); ctx.lineTo(tipX, 0); ctx.lineTo(baseX, triHeight / 2); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(tipX, -triHeight / 2); ctx.lineTo(tipX, triHeight / 2); ctx.stroke();
        }
        
        function drawFWD(el) {
            const { scale } = getDimensionsAndScale(el);
            const triHeight = 12 * scale, baseX = -6 * scale, tipX = 6 * scale, leadLen = 30 * scale;
            ctx.beginPath(); ctx.lineJoin = "round"; ctx.moveTo(-leadLen, 0); ctx.lineTo(baseX, 0); ctx.moveTo(tipX, 0); ctx.lineTo(leadLen, 0); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(baseX, -triHeight / 2); ctx.lineTo(tipX, 0); ctx.lineTo(baseX, triHeight / 2); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(tipX, -triHeight / 2); ctx.lineTo(tipX, triHeight / 2); ctx.stroke();
        }

        function drawZenerDiode(el) {
            drawDiode(el);
            const { scale } = getDimensionsAndScale(el);
            const tipX = 10 * scale, h = 11 * scale, tick = 5 * scale; ctx.beginPath();
            ctx.moveTo(tipX, -h); ctx.lineTo(tipX - tick, -h - tick); ctx.moveTo(tipX, h); ctx.lineTo(tipX + tick, h + tick); ctx.stroke();
        }

        function drawLED(el) {
            drawDiode(el);
            const { scale } = getDimensionsAndScale(el);
            ctx.save(); ctx.lineCap = "round"; ctx.lineWidth *= 0.6; ctx.beginPath();
            ctx.moveTo(-3 * scale, -12 * scale); ctx.lineTo(8 * scale, -24 * scale);
            ctx.moveTo(4 * scale, -22 * scale); ctx.lineTo(8 * scale, -24 * scale); ctx.lineTo(6 * scale, -20 * scale);
            ctx.stroke(); ctx.beginPath();
            ctx.moveTo(2 * scale, -9 * scale); ctx.lineTo(13 * scale, -21 * scale);
            ctx.moveTo(9 * scale, -19 * scale); ctx.lineTo(13 * scale, -21 * scale); ctx.lineTo(11 * scale, -17 * scale);
            ctx.stroke(); ctx.restore();
        }
        
        function drawSwitch(el) {
            const { scale } = getDimensionsAndScale(el);
            const circleRadius = 4 * scale, leftContactX = -15 * scale, rightContactX = 15 * scale, leadLen = 40 * scale;
            ctx.beginPath(); ctx.moveTo(-leadLen, 0); ctx.lineTo(leftContactX, 0); ctx.moveTo(leadLen, 0); ctx.lineTo(rightContactX, 0);
            if (el.state === "closed") { ctx.moveTo(leftContactX, -5 * scale); ctx.lineTo(rightContactX, -5 * scale); } 
            else { const bladeLength = 30 * scale, bladeAngle = (-30 * Math.PI) / 180; ctx.moveTo(leftContactX, 0); ctx.lineTo(leftContactX + bladeLength * Math.cos(bladeAngle), bladeLength * Math.sin(bladeAngle)); }
            ctx.stroke(); ctx.save(); ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(leftContactX, 0, circleRadius, 0, 2 * Math.PI); ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.arc(rightContactX, 0, circleRadius, 0, 2 * Math.PI); ctx.fill(); ctx.stroke(); ctx.restore();
        }

        function drawSpdtSwitch(el) {
            const { scale } = getDimensionsAndScale(el);
            const circleRadius = 4 * scale, commonX = -15 * scale, throwX = 15 * scale, throwY1 = -20 * scale, throwY2 = 20 * scale, leadLen = 40 * scale;
            ctx.beginPath(); ctx.moveTo(-leadLen, 0); ctx.lineTo(commonX, 0); ctx.moveTo(throwX, throwY1); ctx.lineTo(leadLen, throwY1);
            ctx.moveTo(throwX, throwY2); ctx.lineTo(leadLen, throwY2);
            if (el.state === 2) { ctx.moveTo(commonX, 0); ctx.lineTo(throwX, throwY2); } 
            else { ctx.moveTo(commonX, 0); ctx.lineTo(throwX, throwY1); }
            ctx.stroke(); ctx.save(); ctx.fillStyle = "white";
            [{ x: commonX, y: 0 }, { x: throwX, y: throwY1 }, { x: throwX, y: throwY2 }].forEach((p) => {
                ctx.beginPath(); ctx.arc(p.x, p.y, circleRadius, 0, 2 * Math.PI); ctx.fill(); ctx.stroke();
            });
            ctx.restore();
        }
        
        function drawOPAMP(el) {
            const { scale } = getDimensionsAndScale(el);
            ctx.beginPath();
            ctx.moveTo(-50 * scale, -50 * scale); ctx.lineTo(50 * scale, 0); ctx.lineTo(-50 * scale, 50 * scale); ctx.closePath();
            ctx.moveTo(-70 * scale, -20 * scale); ctx.lineTo(-50 * scale, -20 * scale);
            ctx.moveTo(-70 * scale, 20 * scale); ctx.lineTo(-50 * scale, 20 * scale);
            ctx.moveTo(50 * scale, 0); ctx.lineTo(70 * scale, 0);
            ctx.moveTo(-40 * scale, -25 * scale); ctx.lineTo(-40 * scale, -15 * scale);
            ctx.moveTo(-45 * scale, -20 * scale); ctx.lineTo(-35 * scale, -20 * scale);
            ctx.moveTo(-45 * scale, 20 * scale); ctx.lineTo(-35 * scale, 20 * scale);
            ctx.stroke();
        }
        
        function drawArrowhead(ctx, fromX, fromY, toX, toY, scale = 1, headLength = 12) {
            const angle = Math.atan2(toY - fromY, toX - fromX); const arrowAngle = Math.PI / 7;
            const h = headLength * scale;
            ctx.beginPath(); ctx.moveTo(toX, toY);
            ctx.lineTo(toX - h * Math.cos(angle - arrowAngle), toY - h * Math.sin(angle - arrowAngle));
            ctx.lineTo(toX - h * Math.cos(angle + arrowAngle), toY - h * Math.sin(angle + arrowAngle));
            ctx.closePath(); ctx.fill();
        }

        function drawIGBT(el) {
            const { scale } = getDimensionsAndScale(el);
            ctx.beginPath();
            ctx.moveTo(-30*scale, 10*scale); ctx.lineTo(-2*scale, 10*scale); 
            ctx.moveTo(-2*scale, 10*scale); ctx.lineTo(-2*scale, -12*scale);
            ctx.moveTo(5*scale, 20*scale); ctx.lineTo(5*scale, -20*scale);
            ctx.moveTo(4*scale, 20*scale); ctx.lineTo(4*scale, -20*scale);
            ctx.moveTo(30*scale, -20*scale); ctx.lineTo(30*scale, -50*scale);
            ctx.moveTo(30*scale, 20*scale); ctx.lineTo(30*scale, 50*scale);
            ctx.moveTo(30*scale, -20*scale); ctx.lineTo(5*scale, -7*scale);
            const fromX = 5*scale, fromY = 7*scale, toX = 30*scale, toY = 20*scale;
            ctx.moveTo(fromX, fromY); ctx.lineTo(toX, toY); ctx.stroke();
            drawArrowhead(ctx, fromX, fromY, toX, toY, scale);
        }

        

        function drawNFET(el) {
            const { scale } = getDimensionsAndScale(el);
            ctx.beginPath();
            ctx.moveTo(-30*scale, 20*scale); ctx.lineTo(-2*scale, 20*scale);
            ctx.moveTo(-1*scale, 20*scale); ctx.lineTo(-1*scale, -20*scale); ctx.moveTo(-2*scale, 20*scale); ctx.lineTo(-2*scale, -20*scale);
            ctx.moveTo(5*scale, -20*scale); ctx.lineTo(5*scale, -12*scale); ctx.moveTo(5*scale, -16*scale); ctx.lineTo(30*scale, -16*scale);
            ctx.moveTo(5*scale, -4*scale); ctx.lineTo(5*scale, 4*scale); ctx.moveTo(5*scale, 0*scale); ctx.lineTo(30*scale, 0*scale);
            ctx.moveTo(5*scale, 12*scale); ctx.lineTo(5*scale, 20*scale); ctx.moveTo(5*scale, 16*scale); ctx.lineTo(30*scale, 16*scale);
            ctx.moveTo(30*scale, -16*scale); ctx.lineTo(30*scale, -50*scale);
            ctx.moveTo(30*scale, 0*scale); ctx.lineTo(30*scale, 50*scale); ctx.stroke();
            drawArrowhead(ctx, 30*scale, 0*scale, 5*scale, 0*scale, scale);
        }

        function drawPFET(el) {
            const { scale } = getDimensionsAndScale(el);
            ctx.beginPath();
            ctx.moveTo(-30*scale, 20*scale); ctx.lineTo(-2*scale, 20*scale);
            ctx.moveTo(-1*scale, 20*scale); ctx.lineTo(-1*scale, -20*scale); ctx.moveTo(-2*scale, 20*scale); ctx.lineTo(-2*scale, -20*scale);
            ctx.moveTo(5*scale, -20*scale); ctx.lineTo(5*scale, -12*scale); ctx.moveTo(5*scale, -16*scale); ctx.lineTo(30*scale, -16*scale);
            ctx.moveTo(5*scale, -4*scale); ctx.lineTo(5*scale, 4*scale); ctx.moveTo(5*scale, 0*scale); ctx.lineTo(30*scale, 0*scale);
            ctx.moveTo(5*scale, 12*scale); ctx.lineTo(5*scale, 20*scale); ctx.moveTo(5*scale, 16*scale); ctx.lineTo(30*scale, 16*scale);
            ctx.moveTo(30*scale, -16*scale); ctx.lineTo(30*scale, -50*scale);
            ctx.moveTo(30*scale, 0*scale); ctx.lineTo(30*scale, 50*scale); ctx.stroke();
            drawArrowhead(ctx,  5*scale, 0*scale, 30*scale, 0*scale, scale);
        }
        
        function drawNPN(el) {
            const { scale } = getDimensionsAndScale(el);
            ctx.beginPath();
            ctx.moveTo(-30*scale, 0); ctx.lineTo(2*scale, 0);
            ctx.moveTo(3*scale, 20*scale); ctx.lineTo(3*scale, -20*scale); ctx.moveTo(2*scale, 20*scale); ctx.lineTo(2*scale, -20*scale);
            ctx.moveTo(30*scale, -20*scale); ctx.lineTo(30*scale, -52.5*scale);
            ctx.moveTo(30*scale, 20*scale); ctx.lineTo(30*scale, 52.5*scale);
            ctx.moveTo(30*scale, -20*scale); ctx.lineTo(2*scale, -7*scale);
            const fromX = 2*scale, fromY = 7*scale, toX = 30*scale, toY = 20*scale;
            ctx.moveTo(fromX, fromY); ctx.lineTo(toX, toY); ctx.stroke();
            drawArrowhead(ctx, fromX, fromY, toX, toY, scale, 10);
        }

        function drawPNP(el) {
            const { scale } = getDimensionsAndScale(el);
            ctx.beginPath();
            ctx.moveTo(-30*scale, 0); ctx.lineTo(2*scale, 0);
            ctx.moveTo(3*scale, 20*scale); ctx.lineTo(3*scale, -20*scale); ctx.moveTo(2*scale, 20*scale); ctx.lineTo(2*scale, -20*scale);
            ctx.moveTo(30*scale, -20*scale); ctx.lineTo(30*scale, -52.5*scale);
            ctx.moveTo(30*scale, 20*scale); ctx.lineTo(30*scale, 52.5*scale);
            const fromX = 30*scale, fromY = -20*scale, toX = 2*scale, toY = -7*scale;
            ctx.moveTo(fromX, fromY); ctx.lineTo(toX, toY);
            ctx.moveTo(2*scale, 7*scale); ctx.lineTo(30*scale, 20*scale); ctx.stroke();
            drawArrowhead(ctx, fromX, fromY, toX, toY, scale, 10);
        }

        function drawVoltageSource(el) {
            const { scale } = getDimensionsAndScale(el);
            const r = 16 * scale; ctx.beginPath(); ctx.arc(0, 0, r, 0, 2 * Math.PI);
            ctx.moveTo(0, -30 * scale); ctx.lineTo(0, -r); ctx.moveTo(0, r); ctx.lineTo(0, 30 * scale);
            ctx.moveTo(-r / 4, -r / 2); ctx.lineTo(r / 4, -r / 2);
            ctx.moveTo(0, -r / 2 - 5*scale); ctx.lineTo(0, -r / 2 + 5*scale);
            ctx.moveTo(-r / 4, r / 2); ctx.lineTo(r / 4, r / 2); ctx.stroke();
        }

        function drawACVoltageSource(el) {
            const { scale } = getDimensionsAndScale(el);
            const r = 16 * scale; ctx.beginPath(); ctx.arc(0, 0, r, 0, 2 * Math.PI);
            ctx.moveTo(0, -30 * scale); ctx.lineTo(0, -r); ctx.moveTo(0, r); ctx.lineTo(0, 30 * scale);
            const waveStartX = -10 * scale, waveEndX = 10 * scale, waveAmplitude = 8 * scale;
            ctx.moveTo(waveStartX, 0); ctx.quadraticCurveTo(waveStartX / 2, -waveAmplitude, 0, 0);
            ctx.quadraticCurveTo(waveEndX / 2, waveAmplitude, waveEndX, 0); ctx.stroke();
        }

        function drawCurrentSource(el) {
            const { scale } = getDimensionsAndScale(el);
            const r = 16 * scale, arrowY_start = -10 * scale, arrowY_end = 10 * scale, arrowHeadSize = 6 * scale;
            ctx.beginPath(); ctx.arc(0, 0, r, 0, 2 * Math.PI);
            ctx.moveTo(0, -30 * scale); ctx.lineTo(0, -r); ctx.moveTo(0, r); ctx.lineTo(0, 30 * scale);
            ctx.moveTo(-arrowHeadSize / 2, arrowY_start + arrowHeadSize);
            ctx.lineTo(0, arrowY_start); ctx.lineTo(arrowHeadSize / 2, arrowY_start + arrowHeadSize);
            ctx.moveTo(0, arrowY_end); ctx.lineTo(0, 0); ctx.lineTo(0, -5 * scale); ctx.stroke();
        }

        function drawDependentVoltageSource(el) {
            const { scale } = getDimensionsAndScale(el);
            const w = 20 * scale, h = 20 * scale; ctx.beginPath();
            ctx.moveTo(0, -30 * scale); ctx.lineTo(0, -h); ctx.moveTo(0, h); ctx.lineTo(0, 30 * scale);
            ctx.moveTo(0, -h); ctx.lineTo(w, 0); ctx.lineTo(0, h); ctx.lineTo(-w, 0); ctx.closePath();
            const signSize = 4 * scale;
            ctx.moveTo(-signSize, -h * 0.5 + 2*scale); ctx.lineTo(signSize, -h * 0.5 + 2*scale);
            ctx.moveTo(0, -h * 0.5 - signSize + 2*scale); ctx.lineTo(0, -h * 0.5 + signSize + 2*scale);
            ctx.moveTo(-signSize, h * 0.5 - 2*scale); ctx.lineTo(signSize, h * 0.5 - 2*scale); ctx.stroke();
        }
        
        function drawDependentCurrentSource(el) {
            const { scale } = getDimensionsAndScale(el);
            const w = 20 * scale, h = 20 * scale; ctx.beginPath();
            ctx.moveTo(0, -30 * scale); ctx.lineTo(0, -h); ctx.moveTo(0, h); ctx.lineTo(0, 30 * scale);
            ctx.moveTo(0, -h); ctx.lineTo(w, 0); ctx.lineTo(0, h); ctx.lineTo(-w, 0); ctx.closePath();
            const arrowY_start = -h * 0.7, arrowY_end = h * 0.7, arrowHeadSize = 6 * scale;
            ctx.moveTo(0, arrowY_end); ctx.lineTo(0, arrowY_start);
            ctx.moveTo(-arrowHeadSize / 2, arrowY_start + arrowHeadSize);
            ctx.lineTo(0, arrowY_start); ctx.lineTo(arrowHeadSize / 2, arrowY_start + arrowHeadSize); ctx.stroke();
        }
        
        function drawBattery(el) {
            const { scale } = getDimensionsAndScale(el);
            const longPlateW = 34 * scale, shortPlateW = 14 * scale, plateY1 = -5 * scale, plateY2 = 5 * scale;
            const plusSignX = 10 * scale, plusSignY = -16 * scale, plusSignSize = 4 * scale;
            ctx.beginPath(); ctx.moveTo(0, -30 * scale); ctx.lineTo(0, plateY1); ctx.moveTo(0, plateY2); ctx.lineTo(0, 30 * scale);
            ctx.moveTo(-longPlateW / 2, plateY1); ctx.lineTo(longPlateW / 2, plateY1);
            ctx.moveTo(plusSignX - plusSignSize, plusSignY); ctx.lineTo(plusSignX + plusSignSize, plusSignY);
            ctx.moveTo(plusSignX, plusSignY - plusSignSize); ctx.lineTo(plusSignX, plusSignY + plusSignSize);
            ctx.stroke(); ctx.save(); ctx.lineWidth = ctx.lineWidth * 2; ctx.beginPath();
            ctx.moveTo(-shortPlateW / 2, plateY2); ctx.lineTo(shortPlateW / 2, plateY2); ctx.stroke(); ctx.restore();
        }

        function drawGround(el) {
            const { scale } = getDimensionsAndScale(el);
            ctx.beginPath(); ctx.moveTo(0, -10 * scale); ctx.lineTo(0, 0); ctx.moveTo(-15 * scale, 0); ctx.lineTo(15 * scale, 0);
            ctx.moveTo(-10 * scale, 6 * scale); ctx.lineTo(10 * scale, 6 * scale); ctx.moveTo(-5 * scale, 12 * scale); ctx.lineTo(5 * scale, 12 * scale); ctx.stroke();
        }

        function drawArrowMarker(el) {
            const { scale } = getDimensionsAndScale(el);
            ctx.fillStyle = el.color || "black"; ctx.beginPath();
            const length = 16 * scale; const width = 10 * scale;
            ctx.moveTo(length / 2, 0); ctx.lineTo(-length / 2, -width / 2); ctx.lineTo(-length / 2, width / 2); ctx.closePath(); ctx.fill();
        }
        // --- END: SCALE-AWARE DRAWING FUNCTIONS ---

        function calculateBoundingBox() {
          if (circuitElements.length === 0) return null;
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          
          const expandBounds = (p) => {
              minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
              minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
          };

          circuitElements.forEach((el) => {
            if (el.type === "wire") {
              expandBounds(el.start); expandBounds(el.end);
            } else if (el.type === "path-wire" && el.points) {
                el.points.forEach(p => expandBounds(p));
            } else if (el.type === "text") {
              const { width, height } = measureParsedText(el);
              minX = Math.min(minX, el.x - width / 2); maxX = Math.max(maxX, el.x + width / 2);
              minY = Math.min(minY, el.y - height / 2); maxY = Math.max(maxY, el.y + height / 2);
            } else if (el.type === "junction" || el.type === "open_terminal") {
              expandBounds(el);
            } else {
              const { width, height } = getDimensionsAndScale(el);
              const cornerMultipliers = [{x: -0.5, y: -0.5}, {x: 0.5, y: -0.5}, {x: 0.5, y: 0.5},  {x: -0.5, y: 0.5}];
              const scaleX = el.flipH ? -1 : 1, scaleY = el.flipV ? -1 : 1;
              const angle = (el.rotation * Math.PI) / 180;
              const cos = Math.cos(angle), sin = Math.sin(angle);
              cornerMultipliers.forEach(m => {
                  const localX = m.x * width; const localY = m.y * height;
                  const flippedX = localX * scaleX, flippedY = localY * scaleY;
                  const rotatedX = flippedX * cos - flippedY * sin, rotatedY = flippedX * sin + flippedY * cos;
                  expandBounds({x: el.x + rotatedX, y: el.y + rotatedY});
              });
            }
          });
          return { minX, minY, maxX, maxY };
        }

        function appendCircuitFromJSON(jsonString, successMessage = "Circuit appended successfully!") {
          try {
            const data = JSON.parse(jsonString);
            if (data && data.elements && data.nextId !== undefined) {
              const currentBounds = calculateBoundingBox();
              const yOffset = currentBounds ? currentBounds.maxY + 100 : 0;
              const elementsToAppend = [];
              data.elements.forEach((el) => {
                const newEl = JSON.parse(JSON.stringify(el));
                newEl.id = nextId++;
                if (newEl.type === "wire") { newEl.start.y += yOffset; newEl.end.y += yOffset; }
                else if (newEl.type === "path-wire") { newEl.points.forEach(p => p.y += yOffset); }
                else { if (newEl.y !== undefined) newEl.y += yOffset; }
                elementsToAppend.push(newEl);
              });
              if (elementsToAppend.length > 0) { circuitElements.push(...elementsToAppend); }
              const finalBounds = calculateBoundingBox();
              if (finalBounds) { resizeCanvas(finalBounds.maxX + 50, finalBounds.maxY + 50); }
              saveState(); redrawCanvas(); alert(successMessage);
              return true;
            } else { alert("Operation failed: Invalid circuit data structure in the JSON."); return false; }
          } catch (e) { console.error("Could not parse input as circuit JSON.", e); alert("Operation failed: Could not parse JSON. See console for details."); return false; }
        }

        async function handleAIGenerate() {
          const description = prompt("Describe the circuit you want to generate:", "A 9V battery in series with a 470 ohm resistor and a red LED, connected to ground.");
          if (!description) return;
          const API_KEY = "YOUR_GEMINI_API_KEY";
          if (API_KEY === "YOUR_GEMINI_API_KEY") { alert("ERROR: Please open the HTML file, find 'handleAIGenerate', and replace 'YOUR_GEMINI_API_KEY' with your actual Gemini API key."); return; }
          const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${API_KEY}`;
          document.body.style.cursor = "wait";
          alert("Generating circuit with AI... Please wait.");
          const system_prompt = `You are a circuit design assistant for 'Circuit Drafter'. Your ONLY task is to generate a valid JSON object representing a circuit from a user's description. Your output MUST be a single, raw JSON object and nothing else. Do not include explanations or markdown formatting. The JSON structure must be: { "version": "0.42a", "elements": [ ... ], "nextId": <number> }. Valid types: "resistor", "capacitor", "inductor", "diode", "zener", "led", "switch", "spdtSwitch", "voltage", "acvoltage", "currentsource", "battery", "gnd", "npn", "pnp", "nfet", "pfet", "opamp", "igbt", "wire", "text". RULES: Unique integer 'id' starting from 0. 'nextId' is highest 'id' + 1. Wires must connect to component terminals. Use LaTeX for labels (e.g., "R_{1}", "10k\\\\Omega").`;
          try {
            const response = await fetch(API_URL, {
              method: "POST", headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ contents: [{ parts: [{ text: system_prompt }, { text: `\n\n**User Request**: "${description}"` }] }] }),
            });
            if (!response.ok) { const errorBody = await response.json(); throw new Error(`API Error: ${response.status}. ${errorBody.error.message}`); }
            const responseData = await response.json();
            const jsonString = responseData.candidates[0].content.parts[0].text;
            const cleanedJsonString = jsonString.replace(/^```json\s*|```\s*$/g, "");
            appendCircuitFromJSON(cleanedJsonString, "Circuit generated by AI and appended successfully!");
          } catch (error) { console.error("AI Generation Error:", error); alert(`An error occurred: ${error.message}`); } 
          finally { document.body.style.cursor = "default"; }
        }

        geminiAIBtn.addEventListener("click", handleAIGenerate);

        function handleSaveExport() {
          const choiceRaw = prompt("Save as project file (json) or export as image (png)?", "json");
          if (!choiceRaw) return;
          const choice = choiceRaw.toLowerCase().trim();
          if (choice === "json" || choice === "j") saveCircuit();
          else if (choice === "png" || choice === "p") exportCircuit();
          else alert("Invalid choice. Please enter 'json' or 'png'.");
        }

        function saveCircuit() {
          const filename = prompt("Enter filename for project file:", "circuit.json");
          if (!filename) return;
          const dataToSave = { version: "0.48b", elements: circuitElements, nextId: nextId };
          const dataStr = JSON.stringify(dataToSave, null, 2);
          const blob = new Blob([dataStr], { type: "application/json" });
          const link = document.createElement("a");
          link.download = filename.endsWith(".json") ? filename : filename + ".json";
          link.href = URL.createObjectURL(blob);
          document.body.appendChild(link); link.click(); document.body.removeChild(link);
          URL.revokeObjectURL(link.href);
        }

        function handleFileLoad(event) {
          const file = event.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const data = JSON.parse(e.target.result);
              if (data && data.elements && data.nextId !== undefined) {
                circuitElements = data.elements; nextId = data.nextId;
                const bounds = calculateBoundingBox();
                if (bounds) {
                  const padding = 50;
                  const requiredWidth = bounds.maxX + padding; const requiredHeight = bounds.maxY + padding;
                  resizeCanvas(requiredWidth, requiredHeight);
                }
                history = []; historyIndex = -1; selectedElements = [];
                recalculateAutoLabelCounters();
                saveState(); redrawCanvas();
                alert("Circuit loaded successfully!");
              } else { alert("Invalid or corrupted circuit file."); }
            } catch (error) { console.error("Error parsing JSON file:", error); alert("Error reading file. Make sure it is a valid JSON circuit file."); }
            fileInput.value = "";
          };
          reader.readAsText(file);
        }

        function exportCircuit() {
          selectedElements = []; redrawCanvas();
          const scaleFactorStr = prompt("Enter resolution scale factor for PNG (e.g., 2 for 2x resolution):", "2");
          const scaleFactor = parseFloat(scaleFactorStr);
          if (isNaN(scaleFactor) || scaleFactor <= 0) { alert("Invalid scale factor."); return; }
          const bounds = calculateBoundingBox();
          if (!bounds) { alert("Canvas is empty!"); return; }
          const padding = 30;
          const exportCanvas = document.createElement("canvas");
          const exportCtx = exportCanvas.getContext("2d");
          exportCanvas.width = (bounds.maxX - bounds.minX + padding * 2) * scaleFactor;
          exportCanvas.height = (bounds.maxY - bounds.minY + padding * 2) * scaleFactor;
          const originalCtx = ctx; ctx = exportCtx;
          ctx.save(); ctx.fillStyle = "white"; ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
          ctx.scale(scaleFactor, scaleFactor);
          ctx.translate(-bounds.minX + padding, -bounds.minY + padding);
          circuitElements.forEach((el) => drawElement(el));
          drawJunctions();
          ctx.restore();
          ctx = originalCtx;
          const link = document.createElement("a");
          link.download = "circuit-diagram.png";
          link.href = exportCanvas.toDataURL("image/png");
          link.click();
        }

        saveState();
        redrawCanvas();
      });
    </script>
  </body>
</html>
