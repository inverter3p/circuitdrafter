<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Circuit Drafter - Effortless circuit schematics</title>
    <!-- Google Material Icons -->
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0&icon_names=folder_open" />
    <!-- Google Material Icons -->
    
    <!-- Link to Google Font (Outfit) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@700&display=swap" rel="stylesheet">
    
    <style>
      body {
        font-family: "Georgia", "Times New Roman", Times, serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 0;
        padding: 20px;
        background-color: #f8f9fa;
        color: #333;
      }
      h1 {
        font-family: 'Outfit', sans-serif;
        font-weight: 700;
        color: #212529;
      }
      #toolbar {
        margin-bottom: 20px;
        background: #ffffff;
        padding: 10px;
        border-radius: 12px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
        border: 1px solid #e9ecef;
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      .tool-group {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .tool-btn,
      .action-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 44px;
        height: 44px;
        border: 1px solid #ced4da;
        background-color: #ffffff;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease-out;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        font-size: 24px;
        color: #495057;
      }
      .tool-btn:hover,
      .action-btn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        border-color: #adb5bd;
      }
      .tool-btn:active,
      .action-btn:active:not(:disabled) {
        transform: translateY(1px);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        background-color: #f8f9fa;
        transition-duration: 0.1s;
      }
      .tool-btn.selected, .action-btn.selected {
        background-color: #007bff;
        border-color: #007bff;
        color: white;
        box-shadow: 0 2px 5px rgba(0, 123, 255, 0.3);
      }
      .tool-btn svg {
        width: 28px;
        height: 28px;
        stroke-width: 1.5;
        stroke: #495057;
        transition: all 0.2s ease-out;
      }
      /* Universal rule for selected button icons */
      .tool-btn.selected svg, .tool-btn.selected .material-icons,
      .action-btn.selected svg, .action-btn.selected .material-icons {
          stroke: white;
          color: white;
      }
      /* Rule for filling shapes within selected icons */
      .tool-btn.selected svg path[fill]:not([fill="none"]) {
          fill: white;
      }
      /* Rule for filling shapes within normal icons */
      .tool-btn svg path[fill]:not([fill="none"]) {
          fill: #495057;
      }
      /* Specific override for select icon arrow */
      .tool-btn #select-icon-arrow {
          fill: #495057;
      }
      .tool-btn.selected #select-icon-arrow {
          fill: white;
      }
      .divider {
        width: 1px;
        height: 35px;
        background-color: #e9ecef;
        margin: 0 8px;
      }
      .action-btn:disabled {
        color: #adb5bd;
        background-color: #e9ecef;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
        border-color: #ced4da;
      }
      /* --- START: Style for the new green file button --- */
      #fileOpsBtn {
        background-color: #28a745;
        border-color: #28a745;
        color: white;
      }
      #fileOpsBtn:hover:not(:disabled) {
        background-color: #218838;
        border-color: #1e7e34;
      }
      /* --- END: Style for the new green file button --- */
      #circuitCanvas {
        border: 1px solid #dee2e6;
        border-radius: 8px;
        background-color: #fff;
      }
      .tool-dropdown {
        position: relative;
        display: inline-block;
      }
      .dropdown-trigger {
        cursor: default;
      }
      .dropdown-content {
        display: flex;
        flex-direction: column;
        gap: 6px;
        position: absolute;
        top: calc(100% + 5px);
        left: 50%;
        transform: translateX(-50%) translateY(-10px);
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        transition: opacity 0.2s ease-out, transform 0.2s ease-out,
          visibility 0.2s;
        background-color: #ffffff;
        padding: 8px;
        border-radius: 8px;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.12);
        border: 1px solid #e9ecef;
        z-index: 10;
      }
      .tool-dropdown:hover .dropdown-content {
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
        transform: translateX(-50%) translateY(0);
      }
      #helpBtn {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 50px;
        height: 50px;
        background-color: #ffffff;
        border-radius: 50%;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        text-decoration: none;
        transition: all 0.2s ease-out;
      }
      #helpBtn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        background-color: #f8f9fa;
      }
      #helpBtn .material-icons {
        font-size: 28px;
        color: #007bff;
      }
      .title-container {
        display: flex;
        align-items: center;
        gap: 15px;
        margin-bottom: 20px;
      }
      .logo {
        height: 75px;
      }
      h1 {
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        font-weight: 600;
        letter-spacing: 0.5px;
        color: #343a40;
      }
      #tagline {
        margin: 2px 0 0 0;
        font-size: 1.1rem;
        color: #6c757d;
        font-weight: 400;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      }
    </style>
  </head>
  <body>
    <div class="title-container">
      <img src="https://github.com/user-attachments/assets/29b49b83-8617-48fc-aabf-a31d292b27f1" alt="Circuit Drafter Logo" class="logo">
      <div>
        <h1>Circuit Drafter (V0.28a)</h1>
        <p id="tagline">Effortless circuit schematics.</p>
      </div>
    </div>

    <a
      href="https://github.com/inverter3p/circuitdrafter/blob/main/README.md"
      target="_blank"
      rel="noopener noreferrer"
      id="helpBtn"
      title="Help / View Documentation"
    >
      <i class="material-icons">help_outline</i>
    </a>

    <div id="toolbar">
      <div class="tool-group">
        <button class="tool-btn" id="tool-select" title="Select/Move (S)">
          <svg viewBox="0 0 24 24">
            <path
              id="select-icon-box"
              d="M9 14 v7 h12 v-12 h-7"
              stroke-width="2"
              stroke-dasharray="3"
              fill="none"
              stroke-linecap="round"
            />
            <path id="select-icon-arrow" d="M4 3 L15 12 L11 14 L4 3Z" />
          </svg>
        </button>
        <button
          class="tool-btn"
          id="tool-wire"
          title="Wire (W, Shift for straight line, Ctrl+Click for dot)"
        >
          <svg viewBox="0 0 24 24">
            <path
              d="M4 12 L20 12"
              fill="none"
              stroke-linejoin="round"
              stroke-linecap="round"
            ></path>
            <circle cx="4" cy="12" r="2" stroke="red" fill="red" />
            <circle cx="20" cy="12" r="2" stroke="red" fill="red" />
          </svg>
        </button>
        <button class="tool-btn" id="tool-text" title="Text (T)">
          <i class="material-icons">text_fields</i>
        </button>
      </div>
      <div class="divider"></div>
      <div class="tool-group">
        <button class="tool-btn" id="tool-resistor" title="Resistor">
          <svg viewBox="-2 -10 34 20">
            <path
              d="M0,0 H4 L6,-6 L10,6 L14,-6 L18,6 L22,-6 L26,6 L28,0 H32"
              fill="none"
              stroke-linejoin="round"
              stroke-linecap="round"
            ></path>
          </svg>
        </button>
        <button class="tool-btn" id="tool-capacitor" title="Capacitor">
          <svg viewBox="-5 -10 30 20">
            <path
              d="M0,0 H10 M10,-8 V8 M15,-8 V8 M15,0 H25"
              fill="none"
              stroke-linecap="round"
            ></path>
          </svg>
        </button>
        <button class="tool-btn" id="tool-inductor" title="Inductor">
          <svg viewBox="-2 -10 34 20">
            <path
              d="M0,0 H6 C9,-13 12,-13 15,1 C18,-13 21,-13 24,0 H32"
              fill="none"
              stroke-linecap="round"
            ></path>
          </svg>
        </button>
        <button class="tool-btn" id="tool-switch" title="Switch (Double-click to toggle)">
            <svg viewBox="-45 -20 50 40">
                <path d="M-40,0 L-30,0 M-8, 0 L10,0 M-30,0 L-8,-18" stroke-width="2.5" fill="none" stroke-linecap="round"/>
                <circle cx="-30" cy="0" r="4" stroke-width="1.5" fill="white"/>
                <circle cx="-8" cy="0" r="4" stroke-width="1.5" fill="white"/>
            </svg>
        </button>
      </div>
      <div class="divider"></div>
      <div class="tool-group">
        <div class="tool-dropdown">
            <button class="tool-btn dropdown-trigger" title="Diodes">
                <svg viewBox="-2 -10 24 20">
                    <path d="M-4,0 H12 M16,0 H22" fill="none" stroke-linejoin="round" stroke-linecap="round"/>
                    <path fill="#495057" d="M5,-6 V6 L16,0 Z" />
                    <path d="M16,-6 V6" fill="none" stroke-linejoin="round" stroke-linecap="round"/>
                </svg>
            </button>
            <div class="dropdown-content">
                <button class="tool-btn" id="tool-diode" title="Diode">
                    <svg viewBox="-2 -10 24 20">
                        <path d="M-4,0 H12 M16,0 H22" fill="none" stroke-linejoin="round" stroke-linecap="round"/>
                        <path fill="#495057" d="M5,-6 V6 L16,0 Z" />
                        <path d="M16,-6 V6" fill="none" stroke-linejoin="round" stroke-linecap="round"/>
                    </svg>
                </button>
                <button class="tool-btn" id="tool-zener" title="Zener Diode">
                    <svg viewBox="-2 -12 24 24">
                        <path d="M-4,0 H12 M16,0 H22" fill="none" stroke-linejoin="round" stroke-linecap="round"/>
                        <path fill="#495057" d="M5,-6 V6 L16,0 Z" />
                        <path d="M16,-6 V6" fill="none" stroke-linejoin="round" stroke-linecap="round"/>
                        <path d="M16,-6 L13,-8 M16,6 L19,8" stroke-linecap="round"/>
                    </svg>
                </button>
                <button class="tool-btn" id="tool-led" title="LED">
                    <svg viewBox="-2 -16 26 26">
                        <path d="M-4,0 H12 M16,0 H22" fill="none"/>
                        <path d="M5,-6 V6 L16,0 Z" fill="#495057"/>
                        <path d="M16,-6 V6" fill="none"/>
                        <path d="M10,-10 L15,-15 M13,-15 H15 V-13" fill="none" stroke-linecap="round"/>
                        <path d="M14,-8 L19,-13 M17,-13 H19 V-11" fill="none" stroke-linecap="round"/>
                    </svg>
                </button>
            </div>
        </div>
        <div class="tool-dropdown">
          <button class="tool-btn dropdown-trigger" title="Voltage Sources">
            <svg viewBox="-12 -12 24 24">
              <circle cx="0" cy="0" r="10" fill="none"></circle>
              <path d="M-3,-3 H4 M0,-7 V1, M-3,3 H4" fill="none"></path>
            </svg>
          </button>
          <div class="dropdown-content">
            <button
              class="tool-btn"
              id="tool-voltage"
              title="Voltage Source (DC)"
            >
              <svg viewBox="-12 -12 24 24">
                <circle cx="0" cy="0" r="10" fill="none"></circle>
                <path d="M-3,-3 H4 M0,-7 V1, M-3,3 H4" fill="none"></path>
              </svg>
            </button>
            <button
              class="tool-btn"
              id="tool-acvoltage"
              title="Voltage Source (AC)"
            >
              <svg viewBox="-12 -12 24 24">
                <circle cx="0" cy="0" r="10" fill="none"></circle>
                <path
                  d="M-8,0 Q-4,-10 0,0 T8,0"
                  fill="none"
                  stroke-linecap="round"
                ></path>
              </svg>
            </button>
            <button
              class="tool-btn"
              id="tool-currentsource"
              title="Current Source"
            >
              <svg viewBox="-12 -12 24 24">
                <circle cx="0" cy="0" r="10" fill="none"></circle>
                <path d="M0,7 L0,-7 M-4,-2 L0,-7 L4,-2" fill="none" stroke-linecap="round"></path>
              </svg>
            </button>
          </div>
        </div>
        <button class="tool-btn" id="tool-battery" title="Battery">
          <svg viewBox="-10 -10 20 20">
            <path
              d="M-8,-8 H8 M-4,-3 H4 M-8,3 H8 M-4,8 H4"
              stroke-width="1.5"
              fill="none"
            ></path>
          </svg>
        </button>
        <button class="tool-btn" id="tool-gnd" title="Ground">
          <svg viewBox="-10 -2 20 14">
            <path
              d="M0,0 V8 M-8,8 H8 M-5,11 H5 M-2,14 H2"
              fill="none"
              stroke-linecap="round"
            ></path>
          </svg>
        </button>
      </div>
      <div class="divider"></div>
      <div class="tool-group">
        <button class="action-btn" id="undoBtn" title="Undo (Ctrl+Z)">
          <i class="material-icons">undo</i>
        </button>
        <button class="action-btn" id="redoBtn" title="Redo (Ctrl+Y)">
          <i class="material-icons">redo</i>
        </button>
        <button
          class="action-btn"
          id="copyBtn"
          title="Duplicate Selected (Ctrl+D)"
        >
          <i class="material-icons">content_copy</i>
        </button>
        <button class="action-btn" id="rotateBtn" title="Rotate Selected (R)">
          <i class="material-icons">rotate_right</i>
        </button>
        <button class="action-btn" id="deleteBtn" title="Delete Selected (Del)">
          <i class="material-icons">delete</i>
        </button>
      </div>
      <div class="divider"></div>
      <!-- START: File Operations Dropdown -->
      <div class="tool-dropdown">
          <button id="fileOpsBtn" class="action-btn dropdown-trigger" title="File Operations">
              <i class="material-icons">save</i>
          </button>
          <div class="dropdown-content">
              <button class="action-btn" id="saveExportBtn" title="Save or Export... (Ctrl+S)">
                  <i class="material-icons">save_alt</i>
              </button>
              <button class="action-btn" id="loadBtn" title="Load File (Ctrl+O)">
                  <i class="material-symbols-outlined">
folder_open
</i>
              </button>
          </div>
      </div>
      <!-- END: File Operations Dropdown -->
    </div>

    <canvas id="circuitCanvas" width="1000" height="700"></canvas>
    <input type="file" id="fileInput" accept=".json" style="display: none;" />

    <script>
      /****************************************************************************
       * Circuit Drafter - V0.28a (Date: 2024-05-22)
       *
       * SUMMARY OF CHANGES:
       * - Bug Fix (PNG Export): Corrected the drawing context handling,
       *   which was preventing the PNG export from functioning properly.
       * - UI Enhancement (Green Button): The main file operations button
       *   is now styled in green for better visibility.
       ****************************************************************************/
      document.addEventListener("DOMContentLoaded", () => {
        let canvas = document.getElementById("circuitCanvas");
        let ctx = canvas.getContext("2d");
        const fileInput = document.getElementById('fileInput');
        
        let selectedTool = "select";
        let isDrawingWire = false, isDragging = false, isShiftDown = false;
        let wireStartPoint = null, currentMousePos = { x: 0, y: 0 }, dragStartPoint = null;
        let circuitElements = [];
        let nextId = 0;
        const gridSize = 20, snapTolerance = 12, textFontSize = 16;
        let history = [], historyIndex = -1;

        let selectedElements = [];
        let isMarqueeSelecting = false;
        let marqueeStartPoint = null;
        let hoveredWireSegment = null; 

        const componentData = {
          resistor: { width: 80, height: 30, terminals: [{ x: -40, y: 0 }, { x: 40, y: 0 }] }, capacitor: { width: 80, height: 30, terminals: [{ x: -40, y: 0 }, { x: 40, y: 0 }] },
          inductor: { width: 80, height: 30, terminals: [{ x: -40, y: 0 }, { x: 40, y: 0 }] }, diode: { width: 50, height: 30, terminals: [{ x: -25, y: 0 }, { x: 25, y: 0 }] },
          zener: { width: 50, height: 30, terminals: [{ x: -25, y: 0 }, { x: 25, y: 0 }] }, led: { width: 50, height: 30, terminals: [{ x: -25, y: 0 }, { x: 25, y: 0 }] },
          switch: { width: 80, height: 30, terminals: [{ x: -40, y: 0 }, { x: 40, y: 0 }] },
          voltage: { width: 60, height: 60, terminals: [{ x: 0, y: -30 }, { x: 0, y: 30 }] }, acvoltage: { width: 60, height: 60, terminals: [{ x: 0, y: -30 }, { x: 0, y: 30 }] },
          currentsource: { width: 60, height: 60, terminals: [{ x: 0, y: -30 }, { x: 0, y: 30 }] }, battery: { width: 40, height: 60, terminals: [{ x: 0, y: -30 }, { x: 0, y: 30 }] },
          gnd: { width: 30, height: 30, terminals: [{ x: 0, y: -10 }] },
        };

        const actionButtons = {
          undo: document.getElementById("undoBtn"), redo: document.getElementById("redoBtn"), copy: document.getElementById("copyBtn"),
          rotate: document.getElementById("rotateBtn"), delete: document.getElementById("deleteBtn"),
        };

        function updateToolbar() {
          document.querySelectorAll(".tool-btn, .action-btn").forEach((btn) => btn.classList.remove("selected"));
          const currentToolButton = document.getElementById(`tool-${selectedTool}`);
          if (currentToolButton) {
              currentToolButton.classList.add("selected");
              const parentDropdown = currentToolButton.closest('.tool-dropdown');
              if (parentDropdown) parentDropdown.querySelector('.dropdown-trigger').classList.add('selected');
          }
          actionButtons.undo.disabled = historyIndex <= 0;
          actionButtons.redo.disabled = historyIndex >= history.length - 1;
          const isComponentSelected = selectedElements.some(el => el.type !== "wire" && el.type !== "text" && el.type !== 'junction' && el.type !== 'open_terminal');
          actionButtons.rotate.disabled = !isComponentSelected;
          actionButtons.copy.disabled = selectedElements.length === 0;
          actionButtons.delete.disabled = selectedElements.length === 0;
          canvas.style.cursor = selectedTool === "select" ? "default" : "crosshair";
        }

        document.getElementById("toolbar").addEventListener("click", (e) => {
          const target = e.target.closest("button");
          if (!target || target.disabled) return;
          if (target.classList.contains("tool-btn") && !target.classList.contains("dropdown-trigger")) {
            selectedTool = target.id.replace("tool-", "");
            if (selectedTool !== "select") selectedElements = [];
          } else if (target.id === "undoBtn") undo(); else if (target.id === "redoBtn") redo();
          else if (target.id === "copyBtn") copySelected(); else if (target.id === "rotateBtn") rotateSelected();
          else if (target.id === "deleteBtn") deleteSelected();
          else if (target.id === "saveExportBtn") handleSaveExport();
          else if (target.id === 'loadBtn') fileInput.click();
          redrawCanvas();
        });

        window.addEventListener("keydown", (e) => {
          if (document.activeElement.tagName === "INPUT") return;
          if (e.key === "Shift") isShiftDown = true;
          
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            switch (e.key.toLowerCase()) {
              case 'z': undo(); break;
              case 'y': redo(); break;
              case 'd': copySelected(); break;
              case 's': handleSaveExport(); break;
              case 'o': fileInput.click(); break;
            }
          } 
          else {
            switch (e.key.toLowerCase()) {
              case 'r': if (selectedElements.length > 0) { e.preventDefault(); rotateSelected(); } break;
              case 'delete': case 'backspace': if (selectedElements.length > 0) { e.preventDefault(); deleteSelected(); } break;
              case 'w': selectedTool = "wire"; break;
              case 's': selectedTool = "select"; break;
              case 't': selectedTool = "text"; break;
            }
          }
          redrawCanvas();
        });

        window.addEventListener("keyup", (e) => { if (e.key === "Shift") { isShiftDown = false; redrawCanvas(); } });
        window.addEventListener("blur", () => { isShiftDown = false; });
        fileInput.addEventListener('change', handleFileLoad);

        function saveState() {
          history = history.slice(0, historyIndex + 1);
          const cleanState = JSON.parse(JSON.stringify(circuitElements, (key, value) => key === 'dragInitialState' ? undefined : value));
          history.push(cleanState);
          historyIndex++;
          updateToolbar();
        }
        function undo() { if (historyIndex > 0) { historyIndex--; setState(); } }
        function redo() { if (historyIndex < history.length - 1) { historyIndex++; setState(); } }
        function setState() { circuitElements = JSON.parse(JSON.stringify(history[historyIndex])); selectedElements = []; redrawCanvas(); }
        function copySelected() {
          if (selectedElements.length === 0) return;
          const newSelection = [];
          selectedElements.forEach(el => {
              const newEl = JSON.parse(JSON.stringify(el)); newEl.id = nextId++;
              if (newEl.type === 'wire') {
                  newEl.start.x += gridSize; newEl.start.y += gridSize;
                  newEl.end.x += gridSize; newEl.end.y += gridSize;
              } else {
                  newEl.x += gridSize; newEl.y += gridSize;
              }
              circuitElements.push(newEl); newSelection.push(newEl);
          });
          selectedElements = newSelection; saveState(); redrawCanvas();
        }
        function rotateSelected() {
          if (selectedElements.length === 0) return;
          selectedElements.forEach(el => {
              if (el.type !== 'wire' && el.type !== 'text' && el.type !== 'junction' && el.type !== 'open_terminal') { el.rotation = (el.rotation + 45) % 360; }
          });
          saveState(); redrawCanvas();
        }
        function deleteSelected() {
          if (selectedElements.length === 0) return;
          const selectedIds = new Set(selectedElements.map(el => el.id));
          circuitElements = circuitElements.filter(el => !selectedIds.has(el.id));
          selectedElements = []; saveState(); redrawCanvas();
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            circuitElements.forEach((el) => drawElement(el));
            if (hoveredWireSegment) {
                ctx.save(); ctx.strokeStyle = '#007bff'; ctx.lineWidth = 4;
                ctx.shadowColor = 'rgba(0, 123, 255, 0.7)'; ctx.shadowBlur = 8;
                ctx.lineCap = 'round'; ctx.beginPath(); ctx.moveTo(hoveredWireSegment.p1.x, hoveredWireSegment.p1.y);
                ctx.lineTo(hoveredWireSegment.p2.x, hoveredWireSegment.p2.y); ctx.stroke(); ctx.restore();
            }
            drawJunctions();
            drawSelection();
            if (isDrawingWire && wireStartPoint) {
                let endPoint = getSnappingPoint(currentMousePos.x, currentMousePos.y);
                drawWirePreview(wireStartPoint, endPoint);
                drawSnapIndicator(endPoint);
            } else if (selectedTool === "wire") {
                const snapPoint = getSnappingPoint(currentMousePos.x, currentMousePos.y);
                drawSnapIndicator(snapPoint);
            }
            if (isMarqueeSelecting && marqueeStartPoint) { drawMarquee(marqueeStartPoint, currentMousePos); }
            updateToolbar();
        }

        function drawElement(el, isSelected = false) {
          ctx.save();
          setDrawingStyle(isSelected);
          if (el.type === "wire") { drawWire(el, isSelected); }
          else if (el.type === "text") { ctx.translate(el.x, el.y); drawText(el, isSelected); }
          else {
            ctx.translate(el.x, el.y); ctx.rotate((el.rotation * Math.PI) / 180);
            switch (el.type) {
              case "resistor": drawResistor(); break; case "capacitor": drawCapacitor(); break;
              case "inductor": drawInductor(); break; case "diode": drawDiode(); break;
              case "zener": drawZenerDiode(); break; case "led": drawLED(); break;
              case "switch": drawSwitch(el); break; case "voltage": drawVoltageSource(); break;
              case "acvoltage": drawACVoltageSource(); break; case "currentsource": drawCurrentSource(); break;
              case "battery": drawBattery(); break; case "gnd": drawGround(); break; 
              case "junction": drawManualJunction(); break; case "open_terminal": drawOpenTerminal(); break;
            }
          }
          ctx.restore();
        }
        function setDrawingStyle(isSelected = false) {
          ctx.strokeStyle = isSelected ? "#007bff" : "#000";
          ctx.fillStyle = isSelected ? "#007bff" : "#000";
          ctx.lineWidth = isSelected ? 2.5 : 2;
          ctx.lineCap = "round";
        }

        function handleMouseDown(e) {
            const mousePos = getMousePos(e);
            if (e.ctrlKey && !e.metaKey) {
                e.preventDefault();
                const newJunction = { id: nextId++, type: 'junction', x: snapToGrid(mousePos.x), y: snapToGrid(mousePos.y), rotation: 0 };
                circuitElements.push(newJunction);
                saveState(); redrawCanvas(); return;
            }

            let needsStateSave = false;
            if (selectedTool === "select") {
                const clickedElement = getElementAtPos(mousePos.x, mousePos.y);
                if (clickedElement) {
                    isMarqueeSelecting = false; isDragging = true; dragStartPoint = mousePos;
                    if (!selectedElements.some(el => el.id === clickedElement.id)) { selectedElements = [clickedElement]; }
                    selectedElements.forEach(el => { el.dragInitialState = { x: el.x, y: el.y, start: el.start ? { ...el.start } : undefined, end: el.end ? { ...el.end } : undefined }; });
                } else {
                    isMarqueeSelecting = true; isDragging = false; marqueeStartPoint = mousePos; selectedElements = [];
                }
            } else if (selectedTool === "wire") {
                isDrawingWire = true;
                wireStartPoint = getSnappingPoint(mousePos.x, mousePos.y);
            } else if (selectedTool === "text") {
                const textContent = prompt(`Support _ for subscript, ^ for superscript, and \\ for Greek (e.g., \\alpha, \\pi, \\Omega).`, "R_1 = 5 k\\Omega");
                if (textContent) {
                    const newEl = { id: nextId++, type: "text", text: textContent, x: snapToGrid(mousePos.x), y: snapToGrid(mousePos.y), rotation: 0 };
                    circuitElements.push(newEl); selectedTool = "select"; selectedElements = [newEl]; needsStateSave = true;
                }
            } else {
                const newEl = { id: nextId++, type: selectedTool, x: snapToGrid(mousePos.x), y: snapToGrid(mousePos.y), rotation: 0 };
                if (newEl.type === 'switch') { newEl.state = 'open'; }
                circuitElements.push(newEl); selectedTool = "select"; selectedElements = [newEl]; needsStateSave = true;
            }
            if (needsStateSave) saveState();
            redrawCanvas();
        }
        
        function updateHoveredWireSegment() {
            if (selectedTool !== 'wire') { hoveredWireSegment = null; return; }
            hoveredWireSegment = null;
            for (const wire of circuitElements) {
                if (wire.type !== 'wire') continue;
                const path = getWirePath(wire);
                for (let i = 0; i < path.length - 1; i++) {
                    const p1 = path[i]; const p2 = path[i + 1];
                    if (distToSegment(currentMousePos, p1, p2) < snapTolerance) { hoveredWireSegment = { p1, p2 }; return; }
                }
            }
        }

        function handleMouseMove(e) {
            currentMousePos = getMousePos(e);
            if (isDragging && selectedElements.length > 0 && dragStartPoint) {
                const dx = currentMousePos.x - dragStartPoint.x, dy = currentMousePos.y - dragStartPoint.y;
                selectedElements.forEach(el => {
                    const initialState = el.dragInitialState; if (!initialState) return;
                    if (el.type === 'wire') {
                        if (initialState.start && initialState.end) {
                            el.start.x = snapToGrid(initialState.start.x + dx); el.start.y = snapToGrid(initialState.start.y + dy);
                            el.end.x = snapToGrid(initialState.end.x + dx); el.end.y = snapToGrid(initialState.end.y + dy);
                        }
                    } else {
                        if (initialState.x !== undefined && initialState.y !== undefined) {
                           el.x = snapToGrid(initialState.x + dx); el.y = snapToGrid(initialState.y + dy);
                        }
                    }
                });
            }
            updateHoveredWireSegment(); redrawCanvas();
        }

        function handleMouseUp(e) {
          let needsStateSave = false;
          if (isMarqueeSelecting) {
            const rect = { x1: Math.min(marqueeStartPoint.x, currentMousePos.x), y1: Math.min(marqueeStartPoint.y, currentMousePos.y), x2: Math.max(marqueeStartPoint.x, currentMousePos.x), y2: Math.max(marqueeStartPoint.y, currentMousePos.y) };
            selectedElements = circuitElements.filter(el => isElementInRect(el, rect));
          }
          if (isDrawingWire) {
            const endPoint = getSnappingPoint(currentMousePos.x, currentMousePos.y);
            if (Math.hypot(endPoint.x - wireStartPoint.x, endPoint.y - wireStartPoint.y) > 0) {
              circuitElements.push({ id: nextId++, type: "wire", start: wireStartPoint, end: endPoint, routing: isShiftDown ? "direct" : "manhattan"});
              needsStateSave = true;
            }
          }
          if (isDragging) { needsStateSave = true; }
          isDrawingWire = false; isDragging = false; isMarqueeSelecting = false; marqueeStartPoint = null; dragStartPoint = null;
          circuitElements.forEach(el => delete el.dragInitialState);
          if (needsStateSave) saveState();
          redrawCanvas();
        }

        function handleDoubleClick(e) {
            e.preventDefault();
            const mousePos = getMousePos(e);
            const clickedElement = getElementAtPos(mousePos.x, mousePos.y);

            if (clickedElement && clickedElement.type === 'switch') {
                clickedElement.state = (clickedElement.state === 'closed') ? 'open' : 'closed';
                saveState();
                redrawCanvas();
                return;
            }
            
            const newTerminal = { id: nextId++, type: 'open_terminal', x: snapToGrid(mousePos.x), y: snapToGrid(mousePos.y), rotation: 0 };
            circuitElements.push(newTerminal);
            saveState(); redrawCanvas();
        }

        canvas.addEventListener("mousedown", handleMouseDown);
        canvas.addEventListener("mousemove", handleMouseMove);
        canvas.addEventListener("mouseup", handleMouseUp);
        canvas.addEventListener("dblclick", handleDoubleClick);
        canvas.addEventListener("mouseout", () => {
          isDrawingWire = false; isDragging = false; isMarqueeSelecting = false; marqueeStartPoint = null; isShiftDown = false;
          hoveredWireSegment = null; redrawCanvas();
        });
        
        function getMousePos(e) { return { x: e.clientX - canvas.getBoundingClientRect().left, y: e.clientY - canvas.getBoundingClientRect().top }; }
        function snapToGrid(val) { return Math.round(val / (gridSize / 2)) * (gridSize / 2); }

        function getWireSegmentSnapPoint(pos) {
            for (const wire of circuitElements) {
                if (wire.type !== 'wire') continue;
                const path = getWirePath(wire);
                for (let i = 0; i < path.length - 1; i++) {
                    const p1 = path[i]; const p2 = path[i + 1];
                    if (distToSegment(pos, p1, p2) < snapTolerance) { return projectPointOnSegment(pos, p1, p2); }
                }
            }
            return null;
        }

        function getSnappingPoint(x, y) {
            if (selectedTool === 'wire') { const segmentSnap = getWireSegmentSnapPoint({ x, y }); if (segmentSnap) return segmentSnap; }
            for (const el of circuitElements) {
                if (el.type === "wire" || el.type === "text" || el.type === "junction" || el.type === 'open_terminal') continue;
                const terminals = getAbsoluteTerminals(el);
                for (const term of terminals) { if (Math.hypot(x - term.x, y - term.y) < snapTolerance) return { x: term.x, y: term.y, ownerId: el.id }; }
            }
            for (const el of circuitElements) {
                if (el.type === 'junction' || el.type === 'open_terminal') { if (Math.hypot(x - el.x, y - el.y) < snapTolerance) return { x: el.x, y: el.y, ownerId: el.id }; }
            }
            for (const el of circuitElements) {
                if (el.type !== "wire") continue;
                if (Math.hypot(x - el.start.x, y - el.start.y) < snapTolerance) return { x: el.start.x, y: el.start.y };
                if (Math.hypot(x - el.end.x, y - el.end.y) < snapTolerance) return { x: el.end.x, y: el.end.y };
            }
            return { x: snapToGrid(x), y: snapToGrid(y), ownerId: null };
        }

        function getAbsoluteTerminals(el) {
          const data = componentData[el.type];
          if (!data || !data.terminals) return [];
          const angle = (el.rotation * Math.PI) / 180, cos = Math.cos(angle), sin = Math.sin(angle);
          return data.terminals.map((t) => ({ x: el.x + (t.x * cos - t.y * sin), y: el.y + (t.x * sin + t.y * cos) }));
        }
        function getElementAtPos(x, y) {
          for (let i = circuitElements.length - 1; i >= 0; i--) {
            const el = circuitElements[i];
            if (el.type === 'junction' || el.type === 'open_terminal') { if (Math.hypot(x - el.x, y - el.y) < snapTolerance) return el;  }
          }
          for (let i = circuitElements.length - 1; i >= 0; i--) {
            const el = circuitElements[i];
            if (el.type === "wire" || el.type === "junction" || el.type === 'open_terminal') continue;
            if (el.type === "text") {
              const { width, height } = measureParsedText(el.text);
              if (x > el.x - width / 2 && x < el.x + width / 2 && y > el.y - height / 2 && y < el.y + height / 2) return el;
            } else {
              const data = componentData[el.type];
              const dx = x - el.x, dy = y - el.y, angle = (-el.rotation * Math.PI) / 180;
              const rX = dx * Math.cos(angle) - dy * Math.sin(angle), rY = dx * Math.sin(angle) + dy * Math.cos(angle);
              if (Math.abs(rX) < data.width / 2 && Math.abs(rY) < data.height / 2) return el;
            }
          }
          for (let i = circuitElements.length - 1; i >= 0; i--) {
            const el = circuitElements[i];
            if (el.type !== "wire") continue;
            if (isPointOnWire({ x, y }, el)) return el;
          }
          return null;
        }
        function distToSegment(p, v, w) {
          const l2 = (v.x - w.x) ** 2 + (v.y - w.y) ** 2; if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
          let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2; t = Math.max(0, Math.min(1, t));
          return Math.hypot( p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)) );
        }

        function projectPointOnSegment(p, v, w) {
            const l2 = (v.x - w.x) ** 2 + (v.y - w.y) ** 2;
            if (l2 === 0) return { x: v.x, y: v.y };
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            return { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) };
        }

        function isPointOnWire(point, wire) {
          const path = getWirePath(wire);
          for (let i = 0; i < path.length - 1; i++) { if (distToSegment(point, path[i], path[i + 1]) < snapTolerance) return true; }
          return false;
        }
        function isElementInRect(el, rect) {
          if (el.type !== 'wire') { return el.x >= rect.x1 && el.x <= rect.x2 && el.y >= rect.y1 && el.y <= rect.y2; }
          if (el.type === 'wire') {
            const startIn = el.start.x >= rect.x1 && el.start.x <= rect.x2 && el.start.y >= rect.y1 && el.start.y <= rect.y2;
            const endIn = el.end.x >= rect.x1 && el.end.x <= rect.x2 && el.end.y >= rect.y1 && el.end.y <= rect.y2;
            return startIn && endIn;
          }
          return false;
        }

        function drawGrid() {
          ctx.strokeStyle = "#e9ecef"; ctx.lineWidth = 1; ctx.beginPath();
          for (let x = 0; x <= canvas.width; x += gridSize) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); }
          for (let y = 0; y <= canvas.height; y += gridSize) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); }
          ctx.stroke();
        }
        function drawSelection() {
          if (selectedElements.length === 0) return;
          selectedElements.forEach(el => {
              ctx.save();
              ctx.strokeStyle = "#007bff"; ctx.lineWidth = 1; ctx.setLineDash([4, 2]);
              if (el.type === "wire") { drawWire(el, true); }
              else if (el.type === "text") {
                  const { width, height } = measureParsedText(el.text);
                  const padding = 4;
                  ctx.strokeRect(el.x - width / 2 - padding, el.y - height / 2 - padding, width + padding * 2, height + padding * 2);
              } else if (el.type === "junction" || el.type === "open_terminal") {
                  ctx.translate(el.x, el.y); ctx.beginPath(); ctx.arc(0, 0, 8, 0, 2 * Math.PI); ctx.stroke();
              } else {
                  const data = componentData[el.type]; ctx.translate(el.x, el.y); ctx.rotate((el.rotation * Math.PI) / 180);
                  ctx.strokeRect(-data.width / 2, -data.height / 2, data.width, data.height);
              }
              ctx.restore();
          });
        }
        function drawMarquee(start, end) {
            ctx.save();
            ctx.fillStyle = "rgba(0, 123, 255, 0.1)"; ctx.strokeStyle = "rgba(0, 123, 255, 0.5)"; ctx.lineWidth = 1; ctx.setLineDash([6, 3]);
            const width = end.x - start.x, height = end.y - start.y;
            ctx.beginPath(); ctx.rect(start.x, start.y, width, height); ctx.fill(); ctx.stroke();
            ctx.restore();
        }
        function drawSnapIndicator(point) { ctx.beginPath(); ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI); ctx.fillStyle = "rgba(255, 0, 0, 0.5)"; ctx.fill(); }
        function getWirePath(wire) { return wire.routing === "direct" ? [wire.start, wire.end] : [wire.start, { x: wire.start.x, y: wire.end.y }, wire.end]; }
        function drawWireFromPath(path) { ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y); for (let i = 1; i < path.length; i++) { ctx.lineTo(path[i].x, path[i].y); } ctx.stroke(); }
        function drawWire(el, isSelected) { setDrawingStyle(isSelected); drawWireFromPath(getWirePath(el)); }
        function drawWirePreview(start, end) { ctx.save(); setDrawingStyle(true); ctx.setLineDash([4, 4]); drawWireFromPath(getWirePath({ start, end, routing: isShiftDown ? "direct" : "manhattan" })); ctx.restore(); }
        
        function drawJunctions() {
          const connectionPoints = new Map();
          const addPoint = (p) => { const key = `${p.x},${p.y}`; connectionPoints.set(key, (connectionPoints.get(key) || 0) + 1); };
          circuitElements.forEach((el) => {
            if (el.type === "wire") { addPoint(el.start); addPoint(el.end); }
            else if (el.type === 'junction' || el.type === 'open_terminal') { addPoint(el); }
            else if (el.type !== "text") { getAbsoluteTerminals(el).forEach((term) => addPoint(term)); }
          });
          ctx.save(); ctx.fillStyle = "#000";
          for (const [key, count] of connectionPoints.entries()) {
            if (count > 2) { const [x, y] = key.split(",").map(Number); ctx.beginPath(); ctx.arc(x, y, 4, 0, 2 * Math.PI); ctx.fill(); }
          }
          ctx.restore();
        }

        const greekSymbolMap = {
            alpha: "α", beta: "β", gamma: "γ", Delta: "Δ", delta: "δ", epsilon: "ε",
            eta: "η", theta: "θ", lambda: "λ", mu: "μ", pi: "π", rho: "ρ",
            Sigma: "Σ", sigma: "σ", tau: "τ", Phi: "Φ", phi: "φ", Omega: "Ω", omega: "ω",
        };
        function parseText(rawText) {
            const chunks = []; let currentText = ""; let currentType = "normal";
            for (let i = 0; i < rawText.length; i++) {
                const char = rawText[i];
                if (char === "_" || char === "^" || char === " " || char === "\\") {
                    if (currentText.length > 0) { chunks.push({ text: currentText, type: currentType }); }
                    currentText = "";
                    if (char === " ") { currentType = "normal"; currentText = " "; }
                    else if (char === "_") { currentType = "subscript"; }
                    else if (char === "^") { currentType = "superscript"; }
                    else if (char === "\\") {
                        let symbol = "";
                        for (let j = i + 1; j < rawText.length; j++) {
                            const nextChar = rawText[j]; if (nextChar.match(/[a-zA-Z]/)) { symbol += nextChar; } else { break; }
                        }
                        if (greekSymbolMap[symbol]) { chunks.push({ text: greekSymbolMap[symbol], type: "normal" }); i += symbol.length; } else { currentText = "\\"; }
                    }
                } else { currentText += char; }
            }
            if (currentText.length > 0) { chunks.push({ text: currentText, type: currentType }); }
            return chunks;
        }
        function measureParsedText(rawText) {
            const chunks = parseText(rawText); const subSuperScriptScale = 0.7; let totalWidth = 0;
            chunks.forEach(chunk => {
                const fontSize = chunk.type === "normal" ? textFontSize : textFontSize * subSuperScriptScale;
                ctx.font = `italic ${fontSize}px Georgia`;
                totalWidth += ctx.measureText(chunk.text).width;
            });
            return { width: totalWidth, height: textFontSize };
        }
        function drawText(el, isSelected) {
          ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillStyle = isSelected ? "#007bff" : "#000";
          const subSuperScriptScale = 0.85; const subSuperScriptYOffset = 0.35;
          const chunks = parseText(el.text); const { width: totalWidth } = measureParsedText(el.text);
          let currentX = -totalWidth / 2; ctx.textAlign = "left";
          chunks.forEach(chunk => {
            const isNormal = chunk.type === "normal";
            const fontSize = isNormal ? textFontSize : textFontSize * subSuperScriptScale;
            const yOffset = isNormal ? 0 : (chunk.type === "subscript" ? textFontSize * subSuperScriptYOffset : -textFontSize * subSuperScriptYOffset);
            ctx.font = `italic ${fontSize}px Georgia`; ctx.fillText(chunk.text, currentX, yOffset);
            currentX += ctx.measureText(chunk.text).width;
          });
        }
        
        function drawManualJunction() { ctx.beginPath(); ctx.arc(0, 0, 4, 0, 2 * Math.PI); ctx.fillStyle = ctx.strokeStyle; ctx.fill(); }
        function drawOpenTerminal() { ctx.beginPath(); ctx.arc(0, 0, 4, 0, 2 * Math.PI); ctx.fillStyle = '#fff'; ctx.fill(); ctx.strokeStyle = '#000'; ctx.stroke(); }

        function drawResistor() {
          const w = 18, h = 9;
          ctx.beginPath(); ctx.moveTo(-40, 0); ctx.lineTo(-w, 0);
          ctx.moveTo(-w, 0);
          for (let i = 0; i < 6; i++) { ctx.lineTo(-w + (i * 2 + 1) * (w / 6), i % 2 === 0 ? -h : h); }
          ctx.lineTo(w, 0); ctx.lineTo(40, 0); ctx.stroke();
        }
        function drawCapacitor() {
          const plateDist = 10, plateLen = 28;
          ctx.beginPath(); ctx.moveTo(-40, 0); ctx.lineTo(-plateDist / 2, 0);
          ctx.moveTo(-plateDist / 2, -plateLen / 2); ctx.lineTo(-plateDist / 2, plateLen / 2);
          ctx.moveTo(plateDist / 2, -plateLen / 2); ctx.lineTo(plateDist / 2, plateLen / 2);
          ctx.moveTo(plateDist / 2, 0); ctx.lineTo(40, 0); ctx.stroke();
        }
        function drawInductor() {
          const radiusX = 6, radiusY = 12, startX = -21;
          ctx.beginPath(); ctx.lineJoin = "round"; ctx.moveTo(-40, 0); ctx.lineTo(startX, 0);
          ctx.ellipse(-11, 0, radiusX, radiusY, 0, Math.PI, Math.PI / 8, false);
          ctx.ellipse(0, 0, radiusX, radiusY, 0, (Math.PI * 7) / 8, Math.PI / 8, false);
          ctx.ellipse(11, 0, radiusX, radiusY, 0, (Math.PI * 7) / 8, 0, false);
          ctx.lineTo(40, 0); ctx.stroke();
        }
        function drawSwitch(el) {
            const circleRadius = 4, leftContactX = -15, rightContactX = 15;
            ctx.beginPath();
            ctx.moveTo(-40, 0); ctx.lineTo(leftContactX, 0);
            ctx.moveTo(40, 0); ctx.lineTo(rightContactX, 0);
            if (el.state === 'closed') {
                ctx.moveTo(leftContactX, -5);
                ctx.lineTo(rightContactX, -5);
            } else {
                const bladeLength = 30, bladeAngle = -30 * Math.PI / 180;
                ctx.moveTo(leftContactX, 0);
                ctx.lineTo(leftContactX + bladeLength * Math.cos(bladeAngle), bladeLength * Math.sin(bladeAngle));
            }
            ctx.stroke();
            ctx.save(); ctx.fillStyle = "white";
            ctx.beginPath(); ctx.arc(leftContactX, 0, circleRadius, 0, 2 * Math.PI); ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.arc(rightContactX, 0, circleRadius, 0, 2 * Math.PI); ctx.fill(); ctx.stroke();
            ctx.restore();
        }
        function drawDiode() {
          const triHeight = 22, baseX = -10, tipX = 10;
          ctx.beginPath(); ctx.lineJoin = "round"; ctx.moveTo(-25, 0); ctx.lineTo(baseX, 0);
          ctx.moveTo(tipX, 0); ctx.lineTo(25, 0); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(baseX, -triHeight / 2); ctx.lineTo(tipX, 0); ctx.lineTo(baseX, triHeight / 2); ctx.closePath(); ctx.fill();
          ctx.beginPath(); ctx.moveTo(tipX, -triHeight / 2); ctx.lineTo(tipX, triHeight / 2); ctx.stroke();
        }
        function drawZenerDiode() {
            drawDiode();
            const tipX = 10, h = 11, tick = 5;
            ctx.beginPath(); ctx.moveTo(tipX, -h); ctx.lineTo(tipX - tick, -h - tick); ctx.moveTo(tipX, h); ctx.lineTo(tipX + tick, h + tick); ctx.stroke();
        }
        function drawLED() {
            drawDiode();
            ctx.save(); ctx.lineCap = "round";
            ctx.lineWidth = ctx.lineWidth * 0.6; 
            ctx.beginPath(); ctx.moveTo(-3, -12); ctx.lineTo(8, -24); ctx.moveTo(4, -22); ctx.lineTo(8, -24); ctx.lineTo(6, -20); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(2, -9); ctx.lineTo(13, -21); ctx.moveTo(9, -19); ctx.lineTo(13, -21); ctx.lineTo(11, -17); ctx.stroke();
            ctx.restore();
        }
        function drawVoltageSource() {
          const r = 16;
          ctx.beginPath(); ctx.arc(0, 0, r, 0, 2 * Math.PI); ctx.moveTo(0, -30); ctx.lineTo(0, -r);
          ctx.moveTo(0, r); ctx.lineTo(0, 30); ctx.moveTo(-r / 4, -r / 2); ctx.lineTo(r / 4, -r / 2);
          ctx.moveTo(0, -r / 2 - 5); ctx.lineTo(0, -r / 2 + 5); ctx.moveTo(-r / 4, r / 2); ctx.lineTo(r / 4, r / 2); ctx.stroke();
        }
        function drawACVoltageSource() {
          const r = 16;
          ctx.beginPath(); ctx.arc(0, 0, r, 0, 2 * Math.PI); ctx.moveTo(0, -30); ctx.lineTo(0, -r);
          ctx.moveTo(0, r); ctx.lineTo(0, 30); const waveStartX = -10, waveEndX = 10, waveAmplitude = 8;
          ctx.moveTo(waveStartX, 0); ctx.quadraticCurveTo(waveStartX / 2, -waveAmplitude, 0, 0);
          ctx.quadraticCurveTo(waveEndX / 2, waveAmplitude, waveEndX, 0); ctx.stroke();
        }
        function drawBattery() {
          const longPlateW = 34, shortPlateW = 14, plateY1 = -5, plateY2 = 5;
          const plusSignX = 10, plusSignY = -16, plusSignSize = 4;
          ctx.beginPath(); ctx.moveTo(0, -30); ctx.lineTo(0, plateY1); ctx.moveTo(0, plateY2); ctx.lineTo(0, 30);
          ctx.moveTo(-longPlateW / 2, plateY1); ctx.lineTo(longPlateW / 2, plateY1);
          ctx.moveTo(plusSignX - plusSignSize, plusSignY); ctx.lineTo(plusSignX + plusSignSize, plusSignY);
          ctx.moveTo(plusSignX, plusSignY - plusSignSize); ctx.lineTo(plusSignX, plusSignY + plusSignSize);
          ctx.stroke(); ctx.save(); ctx.lineWidth = ctx.lineWidth * 2; ctx.beginPath();
          ctx.moveTo(-shortPlateW / 2, plateY2); ctx.lineTo(shortPlateW / 2, plateY2); ctx.stroke(); ctx.restore();
        }
        function drawGround() {
          ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(0, 0); ctx.moveTo(-15, 0); ctx.lineTo(15, 0);
          ctx.moveTo(-10, 6); ctx.lineTo(10, 6); ctx.moveTo(-5, 12); ctx.lineTo(5, 12); ctx.stroke();
        }
        function drawCurrentSource() {
          const r = 16, arrowY_start = -10, arrowY_end = 10, arrowHeadSize = 6;
          ctx.beginPath(); ctx.arc(0, 0, r, 0, 2 * Math.PI); ctx.moveTo(0, -30); ctx.lineTo(0, -r);
          ctx.moveTo(0, r); ctx.lineTo(0, 30); ctx.moveTo(-arrowHeadSize / 2, arrowY_start + arrowHeadSize);
          ctx.lineTo(0, arrowY_start); ctx.lineTo(arrowHeadSize / 2, arrowY_start + arrowHeadSize);
          ctx.moveTo(0, arrowY_end); ctx.lineTo(0, 0); ctx.lineTo(0, -5); ctx.stroke();
        }
        function calculateBoundingBox() {
            if (circuitElements.length === 0) return null;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            circuitElements.forEach((el) => {
                if (el.type === "wire") {
                    const path = getWirePath(el); path.forEach((p) => { minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x); minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y); });
                } else if (el.type === "text") {
                    const { width, height } = measureParsedText(el.text);
                    minX = Math.min(minX, el.x - width / 2); maxX = Math.max(maxX, el.x + width / 2); minY = Math.min(minY, el.y - height / 2); maxY = Math.max(maxY, el.y + height / 2);
                } else if (el.type === 'junction' || el.type === 'open_terminal') {
                    minX = Math.min(minX, el.x); maxX = Math.max(maxX, el.x); minY = Math.min(minY, el.y); maxY = Math.max(maxY, el.y);
                } else {
                    const data = componentData[el.type]; const w = data.width, h = data.height; const angle = (el.rotation * Math.PI) / 180;
                    const cos = Math.cos(angle), sin = Math.sin(angle);
                    const corners = [{ x: -w / 2, y: -h / 2 }, { x: w / 2, y: -h / 2 }, { x: w / 2, y: h / 2 }, { x: -w / 2, y: h / 2 }];
                    corners.forEach((c) => {
                        const rx = el.x + c.x * cos - c.y * sin; const ry = el.y + c.x * sin + c.y * cos;
                        minX = Math.min(minX, rx); maxX = Math.max(maxX, rx); minY = Math.min(minY, ry); maxY = Math.max(maxY, ry);
                    });
                }
            });
            return { minX, minY, maxX, maxY };
        }

        function handleSaveExport() {
            const choiceRaw = prompt("Save as project file (json) or export as image (png)?", "json");
            if (!choiceRaw) return;
            const choice = choiceRaw.toLowerCase().trim();

            if (choice === 'json' || choice === 'j') {
                saveCircuit();
            } else if (choice === 'png' || choice === 'p') {
                exportCircuit();
            } else {
                alert("Invalid choice. Please enter 'json' or 'png'.");
            }
        }

        function saveCircuit() {
            const filename = prompt("Enter filename for project file:", "circuit.json");
            if (!filename) return;
            const dataToSave = { version: "0.28a", elements: circuitElements, nextId: nextId };
            const dataStr = JSON.stringify(dataToSave, null, 2);
            const blob = new Blob([dataStr], { type: "application/json" });
            const link = document.createElement("a");
            link.download = filename.endsWith('.json') ? filename : filename + '.json';
            link.href = URL.createObjectURL(blob);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
        }

        function handleFileLoad(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data && data.version && data.elements && data.nextId !== undefined) {
                        circuitElements = data.elements;
                        nextId = data.nextId;
                        history = [];
                        historyIndex = -1;
                        selectedElements = [];
                        saveState(); 
                        redrawCanvas();
                        alert('Circuit loaded successfully!');
                    } else {
                        alert('Invalid or corrupted circuit file.');
                    }
                } catch (error) {
                    console.error("Error parsing JSON file:", error);
                    alert('Error reading file. Make sure it is a valid JSON circuit file.');
                }
                fileInput.value = '';
            };
            reader.readAsText(file);
        }

        function exportCircuit() {
            selectedElements = []; redrawCanvas();
            const scaleFactorStr = prompt("Enter resolution scale factor for PNG (e.g., 2 for 2x resolution):", "2");
            const scaleFactor = parseFloat(scaleFactorStr);
            if (isNaN(scaleFactor) || scaleFactor <= 0) { alert("Invalid scale factor."); return; }
            const bounds = calculateBoundingBox(); if (!bounds) { alert("Canvas is empty!"); return; }
            const padding = 30;
            const exportCanvas = document.createElement("canvas");
            const exportCtx = exportCanvas.getContext("2d");
            exportCanvas.width = (bounds.maxX - bounds.minX + padding * 2) * scaleFactor;
            exportCanvas.height = (bounds.maxY - bounds.minY + padding * 2) * scaleFactor;
            
            const originalCtx = ctx;
            ctx = exportCtx;
            
            ctx.save();
            ctx.scale(scaleFactor, scaleFactor);
            ctx.translate(-bounds.minX + padding, -bounds.minY + padding);
            circuitElements.forEach((el) => drawElement(el));
            drawJunctions();
            ctx.restore();
            
            ctx = originalCtx; // BUG FIX: Restore the original context
            
            const link = document.createElement("a");
            link.download = "circuit-diagram.png";
            link.href = exportCanvas.toDataURL("image/png");
            link.click();
        }

        saveState();
        redrawCanvas();
      });
    </script>
  </body>
</html>
